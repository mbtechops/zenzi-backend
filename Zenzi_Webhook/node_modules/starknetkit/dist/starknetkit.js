var ee = Object.defineProperty;
var te = (t, e, r) => e in t ? ee(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var G = (t, e, r) => (te(t, typeof e != "symbol" ? e + "" : e, r), r);
import { W as WebWalletConnector, D as DEFAULT_WEBWALLET_URL } from "./index-34c090a8.js";
import { A as ArgentMobileBaseConnector } from "./index-32a1e8d5.js";
import { BraavosMobileBaseConnector } from "./braavosMobile.js";
import { I as InjectedConnector, A as ARGENT_X_ICON } from "./index-ae0f52d0.js";
import { r as removeStarknetLastConnectedWallet, s as setStarknetLastConnectedWallet } from "./connector-c50f5de7.js";
import "starknet";
import "./getStarknetChainId-7c4b3163.js";
var q = Object.defineProperty, Z = (t, e, r) => e in t ? q(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, O = (t, e, r) => (Z(t, typeof e != "symbol" ? e + "" : e, r), r), Y = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, N = (t, e, r) => (Y(t, e, "read from private field"), r ? r.call(t) : e.get(t)), x = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, k = (t, e, r, n) => (Y(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r), C = (t, e, r) => (Y(t, e, "access private method"), r);
const generateUID = () => `${Date.now()}-${Math.floor(Math.random() * 8999999999999) + 1e12}`, shuffle = (t) => {
  for (let e = t.length - 1; e > 0; e--) {
    const r = Math.floor(Math.random() * (e + 1));
    [t[e], t[r]] = [t[r], t[e]];
  }
  return t;
}, pipe$1 = (...t) => (e) => t.reduce((r, n) => r.then(n), Promise.resolve(e));
function ensureKeysArray(t) {
  return Object.keys(t);
}
const ssrSafeWindow = typeof window < "u" ? window : null;
function getBuilderId() {
  return typeof FEDERATION_BUILD_IDENTIFIER < "u" ? FEDERATION_BUILD_IDENTIFIER : "";
}
function isDebugMode$1() {
  return !!"";
}
function isBrowserEnv$1() {
  return typeof window < "u";
}
const LOG_CATEGORY$1 = "[ Federation Runtime ]";
function assert(t, e) {
  t || error(e);
}
function error(t) {
  throw t instanceof Error ? (t.message = `${LOG_CATEGORY$1}: ${t.message}`, t) : new Error(`${LOG_CATEGORY$1}: ${t}`);
}
function warn$1(t) {
  t instanceof Error ? (t.message = `${LOG_CATEGORY$1}: ${t.message}`, console.warn(t)) : console.warn(`${LOG_CATEGORY$1}: ${t}`);
}
function addUniqueItem(t, e) {
  return t.findIndex((r) => r === e) === -1 && t.push(e), t;
}
function getFMId(t) {
  return "version" in t && t.version ? `${t.name}:${t.version}` : "entry" in t && t.entry ? `${t.name}:${t.entry}` : `${t.name}`;
}
function isRemoteInfoWithEntry(t) {
  return typeof t.entry < "u";
}
function isPureRemoteEntry(t) {
  return !t.entry.includes(".json") && t.entry.includes(".js");
}
function safeToString$1(t) {
  try {
    return JSON.stringify(t, null, 2);
  } catch {
    return "";
  }
}
function isObject(t) {
  return t && typeof t == "object";
}
const objectToString$1 = Object.prototype.toString;
function isPlainObject(t) {
  return objectToString$1.call(t) === "[object Object]";
}
function _extends$1$1() {
  return _extends$1$1 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, _extends$1$1.apply(this, arguments);
}
function _object_without_properties_loose$1(t, e) {
  if (t == null)
    return {};
  var r = {}, n = Object.keys(t), o, i;
  for (i = 0; i < n.length; i++)
    o = n[i], !(e.indexOf(o) >= 0) && (r[o] = t[o]);
  return r;
}
const nativeGlobal = (() => {
  try {
    return new Function("return this")();
  } catch {
    return globalThis;
  }
})(), Global = nativeGlobal;
function definePropertyGlobalVal(t, e, r) {
  Object.defineProperty(t, e, {
    value: r,
    configurable: !1,
    writable: !0
  });
}
function includeOwnProperty(t, e) {
  return Object.hasOwnProperty.call(t, e);
}
includeOwnProperty(globalThis, "__GLOBAL_LOADING_REMOTE_ENTRY__") || definePropertyGlobalVal(globalThis, "__GLOBAL_LOADING_REMOTE_ENTRY__", {});
const globalLoading = globalThis.__GLOBAL_LOADING_REMOTE_ENTRY__;
function setGlobalDefaultVal(t) {
  var e, r, n, o, i, s;
  includeOwnProperty(t, "__VMOK__") && !includeOwnProperty(t, "__FEDERATION__") && definePropertyGlobalVal(t, "__FEDERATION__", t.__VMOK__), includeOwnProperty(t, "__FEDERATION__") || (definePropertyGlobalVal(t, "__FEDERATION__", {
    __GLOBAL_PLUGIN__: [],
    __INSTANCES__: [],
    moduleInfo: {},
    __SHARE__: {},
    __MANIFEST_LOADING__: {},
    __PRELOADED_MAP__: /* @__PURE__ */ new Map()
  }), definePropertyGlobalVal(t, "__VMOK__", t.__FEDERATION__)), (e = t.__FEDERATION__).__GLOBAL_PLUGIN__ != null || (e.__GLOBAL_PLUGIN__ = []), (r = t.__FEDERATION__).__INSTANCES__ != null || (r.__INSTANCES__ = []), (n = t.__FEDERATION__).moduleInfo != null || (n.moduleInfo = {}), (o = t.__FEDERATION__).__SHARE__ != null || (o.__SHARE__ = {}), (i = t.__FEDERATION__).__MANIFEST_LOADING__ != null || (i.__MANIFEST_LOADING__ = {}), (s = t.__FEDERATION__).__PRELOADED_MAP__ != null || (s.__PRELOADED_MAP__ = /* @__PURE__ */ new Map());
}
setGlobalDefaultVal(globalThis);
setGlobalDefaultVal(nativeGlobal);
function getGlobalFederationInstance(t, e) {
  const r = getBuilderId();
  return globalThis.__FEDERATION__.__INSTANCES__.find((n) => !!(r && n.options.id === getBuilderId() || n.options.name === t && !n.options.version && !e || n.options.name === t && e && n.options.version === e));
}
function setGlobalFederationInstance(t) {
  globalThis.__FEDERATION__.__INSTANCES__.push(t);
}
function getGlobalFederationConstructor() {
  return globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__;
}
function setGlobalFederationConstructor(t, e = isDebugMode$1()) {
  e && (globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__ = t, globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR_VERSION__ = "0.1.2");
}
function getInfoWithoutType(t, e) {
  if (typeof e == "string") {
    if (t[e])
      return {
        value: t[e],
        key: e
      };
    {
      const r = Object.keys(t);
      for (const n of r) {
        const [o, i] = n.split(":"), s = `${o}:${e}`, a = t[s];
        if (a)
          return {
            value: a,
            key: s
          };
      }
      return {
        value: void 0,
        key: e
      };
    }
  } else
    throw new Error("key must be string");
}
const getGlobalSnapshot = () => nativeGlobal.__FEDERATION__.moduleInfo, getTargetSnapshotInfoByModuleInfo = (t, e) => {
  const r = getFMId(t), n = getInfoWithoutType(e, r).value;
  if (n && !n.version && "version" in t && t.version && (n.version = t.version), n)
    return n;
  if ("version" in t && t.version) {
    const { version: o } = t, i = _object_without_properties_loose$1(t, [
      "version"
    ]), s = getFMId(i), a = getInfoWithoutType(nativeGlobal.__FEDERATION__.moduleInfo, s).value;
    if (a?.version === o)
      return a;
  }
}, getGlobalSnapshotInfoByModuleInfo = (t) => getTargetSnapshotInfoByModuleInfo(t, nativeGlobal.__FEDERATION__.moduleInfo), setGlobalSnapshotInfoByModuleInfo = (t, e) => {
  const r = getFMId(t);
  return nativeGlobal.__FEDERATION__.moduleInfo[r] = e, nativeGlobal.__FEDERATION__.moduleInfo;
}, addGlobalSnapshot = (t) => (nativeGlobal.__FEDERATION__.moduleInfo = _extends$1$1({}, nativeGlobal.__FEDERATION__.moduleInfo, t), () => {
  const e = Object.keys(t);
  for (const r of e)
    delete nativeGlobal.__FEDERATION__.moduleInfo[r];
}), getRemoteEntryExports = (t, e) => {
  const r = e || `__FEDERATION_${t}:custom__`, n = globalThis[r];
  return {
    remoteEntryKey: r,
    entryExports: n
  };
}, getGlobalHostPlugins = () => nativeGlobal.__FEDERATION__.__GLOBAL_PLUGIN__, getPreloaded = (t) => globalThis.__FEDERATION__.__PRELOADED_MAP__.get(t), setPreloaded = (t) => globalThis.__FEDERATION__.__PRELOADED_MAP__.set(t, !0), DEFAULT_SCOPE = "default", DEFAULT_REMOTE_TYPE = "global", buildIdentifier = "[0-9A-Za-z-]+", build = `(?:\\+(${buildIdentifier}(?:\\.${buildIdentifier})*))`, numericIdentifier = "0|[1-9]\\d*", numericIdentifierLoose = "[0-9]+", nonNumericIdentifier = "\\d*[a-zA-Z-][a-zA-Z0-9-]*", preReleaseIdentifierLoose = `(?:${numericIdentifierLoose}|${nonNumericIdentifier})`, preReleaseLoose = `(?:-?(${preReleaseIdentifierLoose}(?:\\.${preReleaseIdentifierLoose})*))`, preReleaseIdentifier = `(?:${numericIdentifier}|${nonNumericIdentifier})`, preRelease = `(?:-(${preReleaseIdentifier}(?:\\.${preReleaseIdentifier})*))`, xRangeIdentifier = `${numericIdentifier}|x|X|\\*`, xRangePlain = `[v=\\s]*(${xRangeIdentifier})(?:\\.(${xRangeIdentifier})(?:\\.(${xRangeIdentifier})(?:${preRelease})?${build}?)?)?`, hyphenRange = `^\\s*(${xRangePlain})\\s+-\\s+(${xRangePlain})\\s*$`, mainVersionLoose = `(${numericIdentifierLoose})\\.(${numericIdentifierLoose})\\.(${numericIdentifierLoose})`, loosePlain = `[v=\\s]*${mainVersionLoose}${preReleaseLoose}?${build}?`, gtlt = "((?:<|>)?=?)", comparatorTrim = `(\\s*)${gtlt}\\s*(${loosePlain}|${xRangePlain})`, loneTilde = "(?:~>?)", tildeTrim = `(\\s*)${loneTilde}\\s+`, loneCaret = "(?:\\^)", caretTrim = `(\\s*)${loneCaret}\\s+`, star = "(<|>)?=?\\s*\\*", caret = `^${loneCaret}${xRangePlain}$`, mainVersion = `(${numericIdentifier})\\.(${numericIdentifier})\\.(${numericIdentifier})`, fullPlain = `v?${mainVersion}${preRelease}?${build}?`, tilde = `^${loneTilde}${xRangePlain}$`, xRange = `^${gtlt}\\s*${xRangePlain}$`, comparator = `^${gtlt}\\s*(${fullPlain})$|^$`, gte0 = "^\\s*>=\\s*0.0.0\\s*$";
function parseRegex(t) {
  return new RegExp(t);
}
function isXVersion(t) {
  return !t || t.toLowerCase() === "x" || t === "*";
}
function pipe(...t) {
  return (e) => t.reduce((r, n) => n(r), e);
}
function extractComparator(t) {
  return t.match(parseRegex(comparator));
}
function combineVersion(t, e, r, n) {
  const o = `${t}.${e}.${r}`;
  return n ? `${o}-${n}` : o;
}
function parseHyphen(t) {
  return t.replace(parseRegex(hyphenRange), (e, r, n, o, i, s, a, u, l, c, d, m) => (isXVersion(n) ? r = "" : isXVersion(o) ? r = `>=${n}.0.0` : isXVersion(i) ? r = `>=${n}.${o}.0` : r = `>=${r}`, isXVersion(l) ? u = "" : isXVersion(c) ? u = `<${Number(l) + 1}.0.0-0` : isXVersion(d) ? u = `<${l}.${Number(c) + 1}.0-0` : m ? u = `<=${l}.${c}.${d}-${m}` : u = `<=${u}`, `${r} ${u}`.trim()));
}
function parseComparatorTrim(t) {
  return t.replace(parseRegex(comparatorTrim), "$1$2$3");
}
function parseTildeTrim(t) {
  return t.replace(parseRegex(tildeTrim), "$1~");
}
function parseCaretTrim(t) {
  return t.replace(parseRegex(caretTrim), "$1^");
}
function parseCarets(t) {
  return t.trim().split(/\s+/).map((e) => e.replace(parseRegex(caret), (r, n, o, i, s) => isXVersion(n) ? "" : isXVersion(o) ? `>=${n}.0.0 <${Number(n) + 1}.0.0-0` : isXVersion(i) ? n === "0" ? `>=${n}.${o}.0 <${n}.${Number(o) + 1}.0-0` : `>=${n}.${o}.0 <${Number(n) + 1}.0.0-0` : s ? n === "0" ? o === "0" ? `>=${n}.${o}.${i}-${s} <${n}.${o}.${Number(i) + 1}-0` : `>=${n}.${o}.${i}-${s} <${n}.${Number(o) + 1}.0-0` : `>=${n}.${o}.${i}-${s} <${Number(n) + 1}.0.0-0` : n === "0" ? o === "0" ? `>=${n}.${o}.${i} <${n}.${o}.${Number(i) + 1}-0` : `>=${n}.${o}.${i} <${n}.${Number(o) + 1}.0-0` : `>=${n}.${o}.${i} <${Number(n) + 1}.0.0-0`)).join(" ");
}
function parseTildes(t) {
  return t.trim().split(/\s+/).map((e) => e.replace(parseRegex(tilde), (r, n, o, i, s) => isXVersion(n) ? "" : isXVersion(o) ? `>=${n}.0.0 <${Number(n) + 1}.0.0-0` : isXVersion(i) ? `>=${n}.${o}.0 <${n}.${Number(o) + 1}.0-0` : s ? `>=${n}.${o}.${i}-${s} <${n}.${Number(o) + 1}.0-0` : `>=${n}.${o}.${i} <${n}.${Number(o) + 1}.0-0`)).join(" ");
}
function parseXRanges(t) {
  return t.split(/\s+/).map((e) => e.trim().replace(parseRegex(xRange), (r, n, o, i, s, a) => {
    const u = isXVersion(o), l = u || isXVersion(i), c = l || isXVersion(s);
    return n === "=" && c && (n = ""), a = "", u ? n === ">" || n === "<" ? "<0.0.0-0" : "*" : n && c ? (l && (i = 0), s = 0, n === ">" ? (n = ">=", l ? (o = Number(o) + 1, i = 0, s = 0) : (i = Number(i) + 1, s = 0)) : n === "<=" && (n = "<", l ? o = Number(o) + 1 : i = Number(i) + 1), n === "<" && (a = "-0"), `${n + o}.${i}.${s}${a}`) : l ? `>=${o}.0.0${a} <${Number(o) + 1}.0.0-0` : c ? `>=${o}.${i}.0${a} <${o}.${Number(i) + 1}.0-0` : r;
  })).join(" ");
}
function parseStar(t) {
  return t.trim().replace(parseRegex(star), "");
}
function parseGTE0(t) {
  return t.trim().replace(parseRegex(gte0), "");
}
function compareAtom(t, e) {
  return t = Number(t) || t, e = Number(e) || e, t > e ? 1 : t === e ? 0 : -1;
}
function comparePreRelease(t, e) {
  const { preRelease: r } = t, { preRelease: n } = e;
  if (r === void 0 && n)
    return 1;
  if (r && n === void 0)
    return -1;
  if (r === void 0 && n === void 0)
    return 0;
  for (let o = 0, i = r.length; o <= i; o++) {
    const s = r[o], a = n[o];
    if (s !== a)
      return s === void 0 && a === void 0 ? 0 : s ? a ? compareAtom(s, a) : -1 : 1;
  }
  return 0;
}
function compareVersion(t, e) {
  return compareAtom(t.major, e.major) || compareAtom(t.minor, e.minor) || compareAtom(t.patch, e.patch) || comparePreRelease(t, e);
}
function eq(t, e) {
  return t.version === e.version;
}
function compare(t, e) {
  switch (t.operator) {
    case "":
    case "=":
      return eq(t, e);
    case ">":
      return compareVersion(t, e) < 0;
    case ">=":
      return eq(t, e) || compareVersion(t, e) < 0;
    case "<":
      return compareVersion(t, e) > 0;
    case "<=":
      return eq(t, e) || compareVersion(t, e) > 0;
    case void 0:
      return !0;
    default:
      return !1;
  }
}
function parseComparatorString(t) {
  return pipe(
    parseCarets,
    parseTildes,
    parseXRanges,
    parseStar
  )(t);
}
function parseRange(t) {
  return pipe(
    parseHyphen,
    parseComparatorTrim,
    parseTildeTrim,
    parseCaretTrim
  )(t.trim()).split(/\s+/).join(" ");
}
function satisfy(t, e) {
  if (!t)
    return !1;
  const r = parseRange(e).split(" ").map((c) => parseComparatorString(c)).join(" ").split(/\s+/).map((c) => parseGTE0(c)), n = extractComparator(t);
  if (!n)
    return !1;
  const [, o, , i, s, a, u] = n, l = {
    operator: o,
    version: combineVersion(i, s, a, u),
    major: i,
    minor: s,
    patch: a,
    preRelease: u?.split(".")
  };
  for (const c of r) {
    const d = extractComparator(c);
    if (!d)
      return !1;
    const [, m, , g, p, y, w] = d, h = {
      operator: m,
      version: combineVersion(g, p, y, w),
      major: g,
      minor: p,
      patch: y,
      preRelease: w?.split(".")
    };
    if (!compare(h, l))
      return !1;
  }
  return !0;
}
function _extends$6() {
  return _extends$6 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, _extends$6.apply(this, arguments);
}
function formatShare(t, e) {
  let r;
  return "get" in t ? r = t.get : r = () => Promise.resolve(t.lib), _extends$6({
    deps: [],
    useIn: [],
    from: e,
    loading: null
  }, t, {
    shareConfig: _extends$6({
      requiredVersion: `^${t.version}`,
      singleton: !1,
      eager: !1,
      strictVersion: !1
    }, t.shareConfig),
    get: r,
    loaded: "lib" in t ? !0 : void 0,
    scope: Array.isArray(t.scope) ? t.scope : [
      "default"
    ],
    strategy: t.strategy || "version-first"
  });
}
function formatShareConfigs(t, e) {
  return t ? Object.keys(t).reduce((r, n) => (r[n] = formatShare(t[n], e), r), {}) : {};
}
function versionLt(t, e) {
  const r = (n) => {
    if (!Number.isNaN(Number(n))) {
      const o = n.split(".");
      let i = n;
      for (let s = 0; s < 3 - o.length; s++)
        i += ".0";
      return i;
    }
    return n;
  };
  return !!satisfy(r(t), `<=${r(e)}`);
}
const findVersion = (t, e, r, n) => {
  const o = t[e][r], i = n || function(s, a) {
    return versionLt(s, a);
  };
  return Object.keys(o).reduce((s, a) => !s || i(s, a) || s === "0" ? a : s, 0);
}, isLoaded = (t) => !!t.loaded || typeof t.lib == "function";
function findSingletonVersionOrderByVersion(t, e, r) {
  const n = t[e][r];
  return findVersion(t, e, r, function(o, i) {
    return !isLoaded(n[o]) && versionLt(o, i);
  });
}
function findSingletonVersionOrderByLoaded(t, e, r) {
  const n = t[e][r];
  return findVersion(t, e, r, function(o, i) {
    return isLoaded(n[i]) ? isLoaded(n[o]) ? !!versionLt(o, i) : !0 : isLoaded(n[o]) ? !1 : versionLt(o, i);
  });
}
function getFindShareFunction(t) {
  return t === "loaded-first" ? findSingletonVersionOrderByLoaded : findSingletonVersionOrderByVersion;
}
function getRegisteredShare(t, e, r, n) {
  if (!t)
    return;
  const { shareConfig: o, scope: i = DEFAULT_SCOPE, strategy: s } = r, a = Array.isArray(i) ? i : [
    i
  ];
  for (const u of a)
    if (o && t[u] && t[u][e]) {
      const { requiredVersion: l } = o, c = getFindShareFunction(s)(t, u, e), d = () => {
        if (o.singleton) {
          if (typeof l == "string" && !satisfy(c, l)) {
            const g = `Version ${c} from ${c && t[u][e][c].from} of shared singleton module ${e} does not satisfy the requirement of ${r.from} which needs ${l})`;
            o.strictVersion ? error(g) : warn$1(g);
          }
          return t[u][e][c];
        } else {
          if (l === !1 || l === "*" || satisfy(c, l))
            return t[u][e][c];
          for (const [g, p] of Object.entries(t[u][e]))
            if (satisfy(g, l))
              return p;
        }
      }, m = {
        shareScopeMap: t,
        scope: u,
        pkgName: e,
        version: c,
        GlobalFederation: Global.__FEDERATION__,
        resolver: d
      };
      return (n.emit(m) || m).resolver();
    }
}
function getGlobalShareScope() {
  return Global.__FEDERATION__.__SHARE__;
}
function _define_property$3(t, e, r) {
  return e in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
var MANIFEST_EXT = ".json", BROWSER_LOG_KEY = "FEDERATION_DEBUG", BROWSER_LOG_VALUE = "1", NameTransformSymbol = {
  AT: "@",
  HYPHEN: "-",
  SLASH: "/"
}, _obj, NameTransformMap = (_obj = {}, _define_property$3(_obj, NameTransformSymbol.AT, "scope_"), _define_property$3(_obj, NameTransformSymbol.HYPHEN, "_"), _define_property$3(_obj, NameTransformSymbol.SLASH, "__"), _obj), _obj1;
_obj1 = {}, _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.AT], NameTransformSymbol.AT), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.HYPHEN], NameTransformSymbol.HYPHEN), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.SLASH], NameTransformSymbol.SLASH);
var SEPARATOR = ":";
function isBrowserEnv() {
  return typeof window < "u";
}
function isDebugMode() {
  return typeof process < "u" && process.env && process.env.FEDERATION_DEBUG ? !!process.env.FEDERATION_DEBUG : typeof FEDERATION_DEBUG < "u" && !!FEDERATION_DEBUG;
}
function _array_like_to_array$2(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = new Array(e); r < e; r++)
    n[r] = t[r];
  return n;
}
function _array_without_holes(t) {
  if (Array.isArray(t))
    return _array_like_to_array$2(t);
}
function _class_call_check(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
  }
}
function _create_class(t, e, r) {
  return e && _defineProperties(t.prototype, e), r && _defineProperties(t, r), t;
}
function _define_property$2(t, e, r) {
  return e in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
function _iterable_to_array$1(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(t) {
  return _array_without_holes(t) || _iterable_to_array$1(t) || _unsupported_iterable_to_array$2(t) || _non_iterable_spread();
}
function _unsupported_iterable_to_array$2(t, e) {
  if (t) {
    if (typeof t == "string")
      return _array_like_to_array$2(t, e);
    var r = Object.prototype.toString.call(t).slice(8, -1);
    if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set")
      return Array.from(r);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return _array_like_to_array$2(t, e);
  }
}
function safeToString(t) {
  try {
    return JSON.stringify(t, null, 2);
  } catch {
    return "";
  }
}
var DEBUG_LOG = "[ FEDERATION DEBUG ]";
function safeGetLocalStorageItem() {
  try {
    if (typeof window < "u" && window.localStorage)
      return localStorage.getItem(BROWSER_LOG_KEY) === BROWSER_LOG_VALUE;
  } catch {
    return typeof document < "u";
  }
  return !1;
}
var Logger = /* @__PURE__ */ function() {
  function t(e) {
    _class_call_check(this, t), _define_property$2(this, "enable", !1), _define_property$2(this, "identifier", void 0), this.identifier = e || DEBUG_LOG, isBrowserEnv() && safeGetLocalStorageItem() ? this.enable = !0 : isDebugMode() && (this.enable = !0);
  }
  return _create_class(t, [
    {
      key: "info",
      value: function(e, r) {
        if (this.enable) {
          var n = safeToString(r) || "";
          isBrowserEnv() ? console.info("%c ".concat(this.identifier, ": ").concat(e, " ").concat(n), "color:#3300CC") : console.info("\x1B[34m%s", "".concat(this.identifier, ": ").concat(e, " ").concat(n ? `
`.concat(n) : ""));
        }
      }
    },
    {
      key: "logOriginalInfo",
      value: function() {
        for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)
          r[n] = arguments[n];
        if (this.enable)
          if (isBrowserEnv()) {
            var o;
            console.info("%c ".concat(this.identifier, ": OriginalInfo"), "color:#3300CC"), (o = console).log.apply(o, _to_consumable_array(r));
          } else {
            var i;
            console.info("%c ".concat(this.identifier, ": OriginalInfo"), "color:#3300CC"), (i = console).log.apply(i, _to_consumable_array(r));
          }
      }
    }
  ]), t;
}(), LOG_CATEGORY = "[ Federation Runtime ]";
new Logger();
var composeKeyWithSeparator = function() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  return e.length ? e.reduce(function(n, o) {
    return o ? n ? "".concat(n).concat(SEPARATOR).concat(o) : o : n;
  }, "") : "";
}, getResourceUrl = function(t, e) {
  if ("getPublicPath" in t) {
    var r = new Function(t.getPublicPath)();
    return "".concat(r).concat(e);
  } else
    return "publicPath" in t ? "".concat(t.publicPath).concat(e) : (console.warn("Can not get resource url, if in debug mode, please ignore", t, e), "");
}, warn = function(t) {
  console.warn("".concat(LOG_CATEGORY, ": ").concat(t));
};
function _define_property$1(t, e, r) {
  return e in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
function _object_spread$1(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {}, n = Object.keys(r);
    typeof Object.getOwnPropertySymbols == "function" && (n = n.concat(Object.getOwnPropertySymbols(r).filter(function(o) {
      return Object.getOwnPropertyDescriptor(r, o).enumerable;
    }))), n.forEach(function(o) {
      _define_property$1(t, o, r[o]);
    });
  }
  return t;
}
function ownKeys(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function _object_spread_props(t, e) {
  return e = e ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)) : ownKeys(Object(e)).forEach(function(r) {
    Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(e, r));
  }), t;
}
var simpleJoinRemoteEntry = function(t, e) {
  if (!t)
    return e;
  var r = function(o) {
    if (o === ".")
      return "";
    if (o.startsWith("./"))
      return o.replace("./", "");
    if (o.startsWith("/")) {
      var i = o.slice(1);
      return i.endsWith("/") ? i.slice(0, -1) : i;
    }
    return o;
  }, n = r(t);
  return n ? n.endsWith("/") ? "".concat(n).concat(e) : "".concat(n, "/").concat(e) : e;
};
function generateSnapshotFromManifest(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r, n, o = e.remotes, i = o === void 0 ? {} : o, s = e.overrides, a = s === void 0 ? {} : s, u = e.version, l, c = function() {
    return "publicPath" in t.metaData ? t.metaData.publicPath : t.metaData.getPublicPath;
  }, d = Object.keys(a), m = {};
  if (!Object.keys(i).length) {
    var g;
    m = ((g = t.remotes) === null || g === void 0 ? void 0 : g.reduce(function(E, z) {
      var U, B = z.federationContainerName;
      return d.includes(B) ? U = a[B] : "version" in z ? U = z.version : U = z.entry, E[B] = {
        matchedVersion: U
      }, E;
    }, {})) || {};
  }
  Object.keys(i).forEach(function(E) {
    return m[E] = {
      matchedVersion: d.includes(E) ? a[E] : i[E]
    };
  });
  var p = t.metaData, y = p.remoteEntry, w = y.path, h = y.name, M = y.type, b = p.types, A = p.buildInfo.buildVersion, I = p.globalName, j = t.exposes, v = {
    version: u || "",
    buildVersion: A,
    globalName: I,
    remoteEntry: simpleJoinRemoteEntry(w, h),
    remoteEntryType: M,
    remoteTypes: simpleJoinRemoteEntry(b.path, b.name),
    remoteTypesZip: b.zip || "",
    remoteTypesAPI: b.api || "",
    remotesInfo: m,
    shared: t?.shared.map(function(E) {
      return {
        assets: E.assets,
        sharedName: E.name
      };
    }),
    modules: j?.map(function(E) {
      return {
        moduleName: E.name,
        modulePath: E.path,
        assets: E.assets
      };
    })
  };
  if (!((r = t.metaData) === null || r === void 0) && r.prefetchInterface) {
    var S = t.metaData.prefetchInterface;
    v = _object_spread_props(_object_spread$1({}, v), {
      prefetchInterface: S
    });
  }
  if (!((n = t.metaData) === null || n === void 0) && n.prefetchEntry) {
    var D = t.metaData.prefetchEntry, L = D.path, Q = D.name, J = D.type;
    v = _object_spread_props(_object_spread$1({}, v), {
      prefetchEntry: simpleJoinRemoteEntry(L, Q),
      prefetchEntryType: J
    });
  }
  return "publicPath" in t.metaData ? l = _object_spread_props(_object_spread$1({}, v), {
    publicPath: c()
  }) : l = _object_spread_props(_object_spread$1({}, v), {
    getPublicPath: c()
  }), l;
}
function isManifestProvider(t) {
  return !!("remoteEntry" in t && t.remoteEntry.includes(MANIFEST_EXT));
}
function asyncGeneratorStep$1(t, e, r, n, o, i, s) {
  try {
    var a = t[i](s), u = a.value;
  } catch (l) {
    r(l);
    return;
  }
  a.done ? e(u) : Promise.resolve(u).then(n, o);
}
function _async_to_generator$1(t) {
  return function() {
    var e = this, r = arguments;
    return new Promise(function(n, o) {
      var i = t.apply(e, r);
      function s(u) {
        asyncGeneratorStep$1(i, n, o, s, a, "next", u);
      }
      function a(u) {
        asyncGeneratorStep$1(i, n, o, s, a, "throw", u);
      }
      s(void 0);
    });
  };
}
function _instanceof(t, e) {
  return e != null && typeof Symbol < "u" && e[Symbol.hasInstance] ? !!e[Symbol.hasInstance](t) : t instanceof e;
}
function _ts_generator$1(t, e) {
  var r, n, o, i, s = {
    label: 0,
    sent: function() {
      if (o[0] & 1)
        throw o[1];
      return o[1];
    },
    trys: [],
    ops: []
  };
  return i = {
    next: a(0),
    throw: a(1),
    return: a(2)
  }, typeof Symbol == "function" && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function a(l) {
    return function(c) {
      return u([
        l,
        c
      ]);
    };
  }
  function u(l) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; s; )
      try {
        if (r = 1, n && (o = l[0] & 2 ? n.return : l[0] ? n.throw || ((o = n.return) && o.call(n), 0) : n.next) && !(o = o.call(n, l[1])).done)
          return o;
        switch (n = 0, o && (l = [
          l[0] & 2,
          o.value
        ]), l[0]) {
          case 0:
          case 1:
            o = l;
            break;
          case 4:
            return s.label++, {
              value: l[1],
              done: !1
            };
          case 5:
            s.label++, n = l[1], l = [
              0
            ];
            continue;
          case 7:
            l = s.ops.pop(), s.trys.pop();
            continue;
          default:
            if (o = s.trys, !(o = o.length > 0 && o[o.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              s = 0;
              continue;
            }
            if (l[0] === 3 && (!o || l[1] > o[0] && l[1] < o[3])) {
              s.label = l[1];
              break;
            }
            if (l[0] === 6 && s.label < o[1]) {
              s.label = o[1], o = l;
              break;
            }
            if (o && s.label < o[2]) {
              s.label = o[2], s.ops.push(l);
              break;
            }
            o[2] && s.ops.pop(), s.trys.pop();
            continue;
        }
        l = e.call(t, s);
      } catch (c) {
        l = [
          6,
          c
        ], n = 0;
      } finally {
        r = o = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return {
      value: l[0] ? l[1] : void 0,
      done: !0
    };
  }
}
function safeWrapper(t, e) {
  return _safeWrapper.apply(this, arguments);
}
function _safeWrapper() {
  return _safeWrapper = _async_to_generator$1(function(t, e) {
    var r, n;
    return _ts_generator$1(this, function(o) {
      switch (o.label) {
        case 0:
          return o.trys.push([
            0,
            2,
            ,
            3
          ]), [
            4,
            t()
          ];
        case 1:
          return r = o.sent(), [
            2,
            r
          ];
        case 2:
          return n = o.sent(), !e && warn(n), [
            2
          ];
        case 3:
          return [
            2
          ];
      }
    });
  }), _safeWrapper.apply(this, arguments);
}
function isStaticResourcesEqual(t, e) {
  var r = /^(https?:)?\/\//i, n = t.replace(r, "").replace(/\/$/, ""), o = e.replace(r, "").replace(/\/$/, "");
  return n === o;
}
function createScript(t, e, r, n) {
  for (var o = null, i = !0, s = document.getElementsByTagName("script"), a = 0; a < s.length; a++) {
    var u = s[a], l = u.getAttribute("src");
    if (l && isStaticResourcesEqual(l, t)) {
      o = u, i = !1;
      break;
    }
  }
  if (!o && (o = document.createElement("script"), o.type = "text/javascript", o.src = t, n)) {
    var c = n(t);
    _instanceof(c, HTMLScriptElement) && (o = c);
  }
  r && Object.keys(r).forEach(function(m) {
    o && (m === "async" || m === "defer" ? o[m] = r[m] : o.setAttribute(m, r[m]));
  });
  var d = function(m, g) {
    if (o && (o.onerror = null, o.onload = null, safeWrapper(function() {
      o != null && o.parentNode && o.parentNode.removeChild(o);
    }), m)) {
      var p = m(g);
      return e(), p;
    }
    e();
  };
  return o.onerror = d.bind(null, o.onerror), o.onload = d.bind(null, o.onload), {
    script: o,
    needAttach: i
  };
}
function createLink(t, e) {
  for (var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = arguments.length > 3 ? arguments[3] : void 0, o = null, i = !0, s = document.getElementsByTagName("link"), a = 0; a < s.length; a++) {
    var u = s[a], l = u.getAttribute("href"), c = u.getAttribute("ref");
    if (l && isStaticResourcesEqual(l, t) && c === r.ref) {
      o = u, i = !1;
      break;
    }
  }
  if (!o && (o = document.createElement("link"), o.setAttribute("href", t), n)) {
    var d = n(t);
    _instanceof(d, HTMLLinkElement) && (o = d);
  }
  r && Object.keys(r).forEach(function(g) {
    o && o.setAttribute(g, r[g]);
  });
  var m = function(g, p) {
    if (o && (o.onerror = null, o.onload = null, safeWrapper(function() {
      o != null && o.parentNode && o.parentNode.removeChild(o);
    }), g)) {
      var y = g(p);
      return e(), y;
    }
    e();
  };
  return o.onerror = m.bind(null, o.onerror), o.onload = m.bind(null, o.onload), {
    link: o,
    needAttach: i
  };
}
function loadScript(t, e) {
  var r = e.attrs, n = e.createScriptHook;
  return new Promise(function(o, i) {
    var s = createScript(t, o, r, n), a = s.script, u = s.needAttach;
    u && document.getElementsByTagName("head")[0].appendChild(a);
  });
}
function _array_like_to_array(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = new Array(e); r < e; r++)
    n[r] = t[r];
  return n;
}
function _array_with_holes(t) {
  if (Array.isArray(t))
    return t;
}
function asyncGeneratorStep(t, e, r, n, o, i, s) {
  try {
    var a = t[i](s), u = a.value;
  } catch (l) {
    r(l);
    return;
  }
  a.done ? e(u) : Promise.resolve(u).then(n, o);
}
function _async_to_generator(t) {
  return function() {
    var e = this, r = arguments;
    return new Promise(function(n, o) {
      var i = t.apply(e, r);
      function s(u) {
        asyncGeneratorStep(i, n, o, s, a, "next", u);
      }
      function a(u) {
        asyncGeneratorStep(i, n, o, s, a, "throw", u);
      }
      s(void 0);
    });
  };
}
function _iterable_to_array_limit(t, e) {
  var r = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (r != null) {
    var n = [], o = !0, i = !1, s, a;
    try {
      for (r = r.call(t); !(o = (s = r.next()).done) && (n.push(s.value), !(e && n.length === e)); o = !0)
        ;
    } catch (u) {
      i = !0, a = u;
    } finally {
      try {
        !o && r.return != null && r.return();
      } finally {
        if (i)
          throw a;
      }
    }
    return n;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(t, e) {
  return _array_with_holes(t) || _iterable_to_array_limit(t, e) || _unsupported_iterable_to_array(t, e) || _non_iterable_rest();
}
function _unsupported_iterable_to_array(t, e) {
  if (t) {
    if (typeof t == "string")
      return _array_like_to_array(t, e);
    var r = Object.prototype.toString.call(t).slice(8, -1);
    if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set")
      return Array.from(r);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return _array_like_to_array(t, e);
  }
}
function _ts_generator(t, e) {
  var r, n, o, i, s = {
    label: 0,
    sent: function() {
      if (o[0] & 1)
        throw o[1];
      return o[1];
    },
    trys: [],
    ops: []
  };
  return i = {
    next: a(0),
    throw: a(1),
    return: a(2)
  }, typeof Symbol == "function" && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function a(l) {
    return function(c) {
      return u([
        l,
        c
      ]);
    };
  }
  function u(l) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; s; )
      try {
        if (r = 1, n && (o = l[0] & 2 ? n.return : l[0] ? n.throw || ((o = n.return) && o.call(n), 0) : n.next) && !(o = o.call(n, l[1])).done)
          return o;
        switch (n = 0, o && (l = [
          l[0] & 2,
          o.value
        ]), l[0]) {
          case 0:
          case 1:
            o = l;
            break;
          case 4:
            return s.label++, {
              value: l[1],
              done: !1
            };
          case 5:
            s.label++, n = l[1], l = [
              0
            ];
            continue;
          case 7:
            l = s.ops.pop(), s.trys.pop();
            continue;
          default:
            if (o = s.trys, !(o = o.length > 0 && o[o.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              s = 0;
              continue;
            }
            if (l[0] === 3 && (!o || l[1] > o[0] && l[1] < o[3])) {
              s.label = l[1];
              break;
            }
            if (l[0] === 6 && s.label < o[1]) {
              s.label = o[1], o = l;
              break;
            }
            if (o && s.label < o[2]) {
              s.label = o[2], s.ops.push(l);
              break;
            }
            o[2] && s.ops.pop(), s.trys.pop();
            continue;
        }
        l = e.call(t, s);
      } catch (c) {
        l = [
          6,
          c
        ], n = 0;
      } finally {
        r = o = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return {
      value: l[0] ? l[1] : void 0,
      done: !0
    };
  }
}
function importNodeModule(t) {
  if (!t)
    throw new Error("import specifier is required");
  var e = new Function("name", "return import(name)");
  return e(t).then(function(r) {
    return r.default;
  }).catch(function(r) {
    throw console.error("Error importing module ".concat(t, ":"), r), r;
  });
}
function createScriptNode(url, cb, attrs, createScriptHook) {
  if (createScriptHook) {
    var hookResult = createScriptHook(url);
    hookResult && typeof hookResult == "object" && "url" in hookResult && (url = hookResult.url);
  }
  var urlObj;
  try {
    urlObj = new URL(url);
  } catch (t) {
    console.error("Error constructing URL:", t), cb(new Error("Invalid URL: ".concat(t)));
    return;
  }
  var getFetch = function() {
    var t = _async_to_generator(function() {
      var e;
      return _ts_generator(this, function(r) {
        switch (r.label) {
          case 0:
            return typeof fetch > "u" ? [
              4,
              importNodeModule("node-fetch")
            ] : [
              3,
              2
            ];
          case 1:
            return e = r.sent(), [
              2,
              e?.default || e
            ];
          case 2:
            return [
              2,
              fetch
            ];
          case 3:
            return [
              2
            ];
        }
      });
    });
    return function() {
      return t.apply(this, arguments);
    };
  }();
  console.log("fetching", urlObj.href), getFetch().then(function(f) {
    f(urlObj.href).then(function(t) {
      return t.text();
    }).then(function() {
      var _ref = _async_to_generator(function(data) {
        var _ref, path, vm, scriptContext, urlDirname, filename, script, exportedInterface, container;
        return _ts_generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                Promise.all([
                  importNodeModule("path"),
                  importNodeModule("vm")
                ])
              ];
            case 1:
              _ref = _sliced_to_array.apply(void 0, [
                _state.sent(),
                2
              ]), path = _ref[0], vm = _ref[1], scriptContext = {
                exports: {},
                module: {
                  exports: {}
                }
              }, urlDirname = urlObj.pathname.split("/").slice(0, -1).join("/"), filename = path.basename(urlObj.pathname);
              try {
                if (script = new vm.Script("(function(exports, module, require, __dirname, __filename) {".concat(data, `
})`), filename), script.runInThisContext()(scriptContext.exports, scriptContext.module, eval("require"), urlDirname, filename), exportedInterface = scriptContext.module.exports || scriptContext.exports, attrs && exportedInterface && attrs.globalName)
                  return container = exportedInterface[attrs.globalName] || exportedInterface, cb(void 0, container), [
                    2
                  ];
                cb(void 0, exportedInterface);
              } catch (t) {
                cb(new Error("Script execution error: ".concat(t)));
              }
              return [
                2
              ];
          }
        });
      });
      return function(t) {
        return _ref.apply(this, arguments);
      };
    }()).catch(function(t) {
      cb(t);
    });
  });
}
function loadScriptNode(t, e) {
  return new Promise(function(r, n) {
    createScriptNode(t, function(o, i) {
      if (o)
        n(o);
      else {
        var s, a, u = (e == null || (s = e.attrs) === null || s === void 0 ? void 0 : s.globalName) || "__FEDERATION_".concat(e == null || (a = e.attrs) === null || a === void 0 ? void 0 : a.name, ":custom__"), l = globalThis[u] = i;
        r(l);
      }
    }, e.attrs, e.createScriptHook);
  });
}
function matchRemoteWithNameAndExpose(t, e) {
  for (const r of t) {
    const n = e.startsWith(r.name);
    let o = e.replace(r.name, "");
    if (n) {
      if (o.startsWith("/")) {
        const a = r.name;
        return o = `.${o}`, {
          pkgNameOrAlias: a,
          expose: o,
          remote: r
        };
      } else if (o === "")
        return {
          pkgNameOrAlias: r.name,
          expose: ".",
          remote: r
        };
    }
    const i = r.alias && e.startsWith(r.alias);
    let s = r.alias && e.replace(r.alias, "");
    if (r.alias && i) {
      if (s && s.startsWith("/")) {
        const a = r.alias;
        return s = `.${s}`, {
          pkgNameOrAlias: a,
          expose: s,
          remote: r
        };
      } else if (s === "")
        return {
          pkgNameOrAlias: r.alias,
          expose: ".",
          remote: r
        };
    }
  }
}
function matchRemote(t, e) {
  for (const r of t)
    if (e === r.name || r.alias && e === r.alias)
      return r;
}
function registerPlugins(t, e) {
  const r = getGlobalHostPlugins();
  r.length > 0 && r.forEach((n) => {
    t != null && t.find((o) => o.name !== n.name) && t.push(n);
  }), t && t.length > 0 && t.forEach((n) => {
    e.forEach((o) => {
      o.applyPlugin(n);
    });
  });
}
function _extends$5() {
  return _extends$5 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, _extends$5.apply(this, arguments);
}
async function loadEsmEntry({ entry: t, remoteEntryExports: e }) {
  return new Promise((r, n) => {
    try {
      e ? r(e) : new Function("callbacks", `import("${t}").then(callbacks[0]).catch(callbacks[1])`)([
        r,
        n
      ]);
    } catch (o) {
      n(o);
    }
  });
}
async function loadEntryScript({ name: t, globalName: e, entry: r, createScriptHook: n }) {
  const { entryExports: o } = getRemoteEntryExports(t, e);
  return o || (typeof document > "u" ? loadScriptNode(r, {
    attrs: {
      name: t,
      globalName: e
    },
    createScriptHook: n
  }).then(() => {
    const { remoteEntryKey: i, entryExports: s } = getRemoteEntryExports(t, e);
    return assert(s, `
        Unable to use the ${t}'s '${r}' URL with ${i}'s globalName to get remoteEntry exports.
        Possible reasons could be:

        1. '${r}' is not the correct URL, or the remoteEntry resource or name is incorrect.

        2. ${i} cannot be used to get remoteEntry exports in the window object.
      `), s;
  }).catch((i) => i) : loadScript(r, {
    attrs: {},
    createScriptHook: n
  }).then(() => {
    const { remoteEntryKey: i, entryExports: s } = getRemoteEntryExports(t, e);
    return assert(s, `
      Unable to use the ${t}'s '${r}' URL with ${i}'s globalName to get remoteEntry exports.
      Possible reasons could be:

      1. '${r}' is not the correct URL, or the remoteEntry resource or name is incorrect.

      2. ${i} cannot be used to get remoteEntry exports in the window object.
    `), s;
  }).catch((i) => i));
}
function getRemoteEntryUniqueKey(t) {
  const { entry: e, name: r } = t;
  return composeKeyWithSeparator(r, e);
}
async function getRemoteEntry({ remoteEntryExports: t, remoteInfo: e, createScriptHook: r }) {
  const { entry: n, name: o, type: i, entryGlobalName: s } = e, a = getRemoteEntryUniqueKey(e);
  return t || (globalLoading[a] || (i === "esm" ? globalLoading[a] = loadEsmEntry({
    entry: n,
    remoteEntryExports: t
  }) : globalLoading[a] = loadEntryScript({
    name: o,
    globalName: s,
    entry: n,
    createScriptHook: r
  })), globalLoading[a]);
}
function getRemoteInfo(t) {
  return _extends$5({}, t, {
    entry: "entry" in t ? t.entry : "",
    type: t.type || DEFAULT_REMOTE_TYPE,
    entryGlobalName: t.entryGlobalName || t.name,
    shareScope: t.shareScope || DEFAULT_SCOPE
  });
}
function _extends$4() {
  return _extends$4 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, _extends$4.apply(this, arguments);
}
let Module = class {
  async getEntry() {
    if (this.remoteEntryExports)
      return this.remoteEntryExports;
    const t = await getRemoteEntry({
      remoteInfo: this.remoteInfo,
      remoteEntryExports: this.remoteEntryExports,
      createScriptHook: (e) => {
        const r = this.host.loaderHook.lifecycle.createScript.emit({
          url: e
        });
        if (typeof document > "u" || r instanceof HTMLScriptElement)
          return r;
      }
    });
    return assert(t, `remoteEntryExports is undefined 
 ${safeToString$1(this.remoteInfo)}`), this.remoteEntryExports = t, this.remoteEntryExports;
  }
  async get(t, e) {
    const { loadFactory: r = !0 } = e || {
      loadFactory: !0
    }, n = await this.getEntry();
    if (!this.inited) {
      const i = this.host.shareScopeMap, s = this.remoteInfo.shareScope || "default";
      i[s] || (i[s] = {});
      const a = i[s], u = [], l = {
        version: this.remoteInfo.version || ""
      };
      Object.defineProperty(l, "hostId", {
        value: this.host.options.id || this.host.name,
        enumerable: !1
      });
      const c = await this.host.hooks.lifecycle.beforeInitContainer.emit({
        shareScope: a,
        remoteEntryInitOptions: l,
        initScope: u,
        remoteInfo: this.remoteInfo,
        origin: this.host
      });
      await n.init(c.shareScope, c.initScope, c.remoteEntryInitOptions), await this.host.hooks.lifecycle.initContainer.emit(_extends$4({}, c, {
        remoteEntryExports: n
      }));
    }
    this.lib = n, this.inited = !0;
    const o = await n.get(t);
    return assert(o, `${getFMId(this.remoteInfo)} remote don't export ${t}.`), r ? await o() : o;
  }
  constructor({ remoteInfo: t, host: e }) {
    this.inited = !1, this.lib = void 0, this.remoteInfo = t, this.host = e;
  }
};
class SyncHook {
  on(e) {
    typeof e == "function" && this.listeners.add(e);
  }
  once(e) {
    const r = this;
    this.on(function n(...o) {
      return r.remove(n), e.apply(null, o);
    });
  }
  emit(...e) {
    let r;
    return this.listeners.size > 0 && this.listeners.forEach((n) => {
      r = n(...e);
    }), r;
  }
  remove(e) {
    this.listeners.delete(e);
  }
  removeAll() {
    this.listeners.clear();
  }
  constructor(e) {
    this.type = "", this.listeners = /* @__PURE__ */ new Set(), e && (this.type = e);
  }
}
class AsyncHook extends SyncHook {
  emit(...e) {
    let r;
    const n = Array.from(this.listeners);
    if (n.length > 0) {
      let o = 0;
      const i = (s) => s === !1 ? !1 : o < n.length ? Promise.resolve(n[o++].apply(null, e)).then(i) : s;
      r = i();
    }
    return Promise.resolve(r);
  }
}
function checkReturnData(t, e) {
  if (!isObject(e))
    return !1;
  if (t !== e) {
    for (const r in t)
      if (!(r in e))
        return !1;
  }
  return !0;
}
class SyncWaterfallHook extends SyncHook {
  emit(e) {
    isObject(e) || error(`The data for the "${this.type}" hook should be an object.`);
    for (const r of this.listeners)
      try {
        const n = r(e);
        if (checkReturnData(e, n))
          e = n;
        else {
          this.onerror(`A plugin returned an unacceptable value for the "${this.type}" type.`);
          break;
        }
      } catch (n) {
        warn$1(n), this.onerror(n);
      }
    return e;
  }
  constructor(e) {
    super(), this.onerror = error, this.type = e;
  }
}
class AsyncWaterfallHook extends SyncHook {
  emit(e) {
    isObject(e) || error(`The response data for the "${this.type}" hook must be an object.`);
    const r = Array.from(this.listeners);
    if (r.length > 0) {
      let n = 0;
      const o = (s) => (warn$1(s), this.onerror(s), e), i = (s) => {
        if (checkReturnData(e, s)) {
          if (e = s, n < r.length)
            try {
              return Promise.resolve(r[n++](e)).then(i, o);
            } catch (a) {
              return o(a);
            }
        } else
          this.onerror(`A plugin returned an incorrect value for the "${this.type}" type.`);
        return e;
      };
      return Promise.resolve(i(e));
    }
    return Promise.resolve(e);
  }
  constructor(e) {
    super(), this.onerror = error, this.type = e;
  }
}
class PluginSystem {
  applyPlugin(e) {
    assert(isPlainObject(e), "Plugin configuration is invalid.");
    const r = e.name;
    assert(r, "A name must be provided by the plugin."), this.registerPlugins[r] || (this.registerPlugins[r] = e, Object.keys(this.lifecycle).forEach((n) => {
      const o = e[n];
      o && this.lifecycle[n].on(o);
    }));
  }
  removePlugin(e) {
    assert(e, "A name is required.");
    const r = this.registerPlugins[e];
    assert(r, `The plugin "${e}" is not registered.`), Object.keys(r).forEach((n) => {
      n !== "name" && this.lifecycle[n].remove(r[n]);
    });
  }
  inherit({ lifecycle: e, registerPlugins: r }) {
    Object.keys(e).forEach((n) => {
      assert(!this.lifecycle[n], `The hook "${n}" has a conflict and cannot be inherited.`), this.lifecycle[n] = e[n];
    }), Object.keys(r).forEach((n) => {
      assert(!this.registerPlugins[n], `The plugin "${n}" has a conflict and cannot be inherited.`), this.applyPlugin(r[n]);
    });
  }
  constructor(e) {
    this.registerPlugins = {}, this.lifecycle = e, this.lifecycleKeys = Object.keys(e);
  }
}
function _extends$3() {
  return _extends$3 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, _extends$3.apply(this, arguments);
}
function defaultPreloadArgs(t) {
  return _extends$3({
    resourceCategory: "sync",
    share: !0,
    depsRemote: !0,
    prefetchInterface: !1
  }, t);
}
function formatPreloadArgs(t, e) {
  return e.map((r) => {
    const n = matchRemote(t, r.nameOrAlias);
    return assert(n, `Unable to preload ${r.nameOrAlias} as it is not included in ${!n && safeToString$1({
      remoteInfo: n,
      remotes: t
    })}`), {
      remote: n,
      preloadConfig: defaultPreloadArgs(r)
    };
  });
}
function normalizePreloadExposes(t) {
  return t ? t.map((e) => e === "." ? e : e.startsWith("./") ? e.replace("./", "") : e) : [];
}
function preloadAssets(t, e, r) {
  const { cssAssets: n, jsAssetsWithoutEntry: o, entryAssets: i } = r;
  if (e.options.inBrowser) {
    i.forEach((a) => {
      const { moduleInfo: u } = a, l = e.moduleCache.get(t.name);
      getRemoteEntry(l ? {
        remoteInfo: u,
        remoteEntryExports: l.remoteEntryExports,
        createScriptHook: (c) => {
          const d = e.loaderHook.lifecycle.createScript.emit({
            url: c
          });
          if (d instanceof HTMLScriptElement)
            return d;
        }
      } : {
        remoteInfo: u,
        remoteEntryExports: void 0,
        createScriptHook: (c) => {
          const d = e.loaderHook.lifecycle.createScript.emit({
            url: c
          });
          if (d instanceof HTMLScriptElement)
            return d;
        }
      });
    });
    const s = document.createDocumentFragment();
    n.forEach((a) => {
      const { link: u, needAttach: l } = createLink(a, () => {
      }, {
        rel: "preload",
        as: "style"
      }, (c) => {
        const d = e.loaderHook.lifecycle.createLink.emit({
          url: c
        });
        if (d instanceof HTMLLinkElement)
          return d;
      });
      l && s.appendChild(u);
    }), o.forEach((a) => {
      const { link: u, needAttach: l } = createLink(a, () => {
      }, {
        rel: "preload",
        as: "script"
      }, (c) => {
        const d = e.loaderHook.lifecycle.createLink.emit({
          url: c
        });
        if (d instanceof HTMLLinkElement)
          return d;
      });
      l && document.head.appendChild(u);
    }), document.head.appendChild(s);
  }
}
function _extends$2() {
  return _extends$2 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, _extends$2.apply(this, arguments);
}
function assignRemoteInfo(t, e) {
  (!("remoteEntry" in e) || !e.remoteEntry) && error(`The attribute remoteEntry of ${name} must not be undefined.`);
  const { remoteEntry: r } = e, n = getResourceUrl(e, r);
  t.type = e.remoteEntryType, t.entryGlobalName = e.globalName, t.entry = n, t.version = e.version, t.buildVersion = e.buildVersion;
}
function snapshotPlugin() {
  return {
    name: "snapshot-plugin",
    async afterResolve(t) {
      const { remote: e, pkgNameOrAlias: r, expose: n, origin: o, remoteInfo: i } = t;
      if (!isRemoteInfoWithEntry(e) || !isPureRemoteEntry(e)) {
        const { remoteSnapshot: s, globalSnapshot: a } = await o.snapshotHandler.loadRemoteSnapshotInfo(e);
        assignRemoteInfo(i, s);
        const u = {
          remote: e,
          preloadConfig: {
            nameOrAlias: r,
            exposes: [
              n
            ],
            resourceCategory: "sync",
            share: !1,
            depsRemote: !1
          }
        }, l = await o.hooks.lifecycle.generatePreloadAssets.emit({
          origin: o,
          preloadOptions: u,
          remoteInfo: i,
          remote: e,
          remoteSnapshot: s,
          globalSnapshot: a
        });
        return l && preloadAssets(i, o, l), _extends$2({}, t, {
          remoteSnapshot: s
        });
      }
      return t;
    }
  };
}
function splitId(t) {
  const e = t.split(":");
  return e.length === 1 ? {
    name: e[0],
    version: void 0
  } : e.length === 2 ? {
    name: e[0],
    version: e[1]
  } : {
    name: e[1],
    version: e[2]
  };
}
function traverseModuleInfo(t, e, r, n, o = {}, i) {
  const s = getFMId(e), { value: a } = getInfoWithoutType(t, s), u = i || a;
  if (u && !isManifestProvider(u) && (r(u, e, n), u.remotesInfo)) {
    const l = Object.keys(u.remotesInfo);
    for (const c of l) {
      if (o[c])
        continue;
      o[c] = !0;
      const d = splitId(c), m = u.remotesInfo[c];
      traverseModuleInfo(t, {
        name: d.name,
        version: m.matchedVersion
      }, r, !1, o, void 0);
    }
  }
}
function generatePreloadAssets(t, e, r, n, o) {
  const i = [], s = [], a = [], u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set(), { options: c } = t, { preloadConfig: d } = e, { depsRemote: m } = d;
  traverseModuleInfo(n, r, (p, y, w) => {
    let h;
    if (w)
      h = d;
    else if (Array.isArray(m)) {
      const v = m.find((S) => S.nameOrAlias === y.name || S.nameOrAlias === y.alias);
      if (!v)
        return;
      h = defaultPreloadArgs(v);
    } else if (m === !0)
      h = d;
    else
      return;
    const M = getResourceUrl(p, "remoteEntry" in p ? p.remoteEntry : "");
    M && a.push({
      name: y.name,
      moduleInfo: {
        name: y.name,
        entry: M,
        type: "remoteEntryType" in p ? p.remoteEntryType : "global",
        entryGlobalName: "globalName" in p ? p.globalName : y.name,
        shareScope: "",
        version: "version" in p ? p.version : void 0
      },
      url: M
    });
    let b = "modules" in p ? p.modules : [];
    const A = normalizePreloadExposes(h.exposes);
    if (A.length && "modules" in p) {
      var I;
      b = p == null || (I = p.modules) == null ? void 0 : I.reduce((v, S) => (A?.indexOf(S.moduleName) !== -1 && v.push(S), v), []);
    }
    function j(v) {
      const S = v.map((D) => getResourceUrl(p, D));
      return h.filter ? S.filter(h.filter) : S;
    }
    if (b) {
      const v = b.length;
      for (let S = 0; S < v; S++) {
        const D = b[S], L = `${y.name}/${D.moduleName}`;
        t.hooks.lifecycle.handlePreloadModule.emit({
          id: D.moduleName === "." ? y.name : L,
          name: y.name,
          remoteSnapshot: p,
          preloadConfig: h,
          remote: y,
          origin: t
        }), !getPreloaded(L) && (h.resourceCategory === "all" ? (i.push(...j(D.assets.css.async)), i.push(...j(D.assets.css.sync)), s.push(...j(D.assets.js.async)), s.push(...j(D.assets.js.sync))) : (h.resourceCategory = "sync") && (i.push(...j(D.assets.css.sync)), s.push(...j(D.assets.js.sync))), setPreloaded(L));
      }
    }
  }, !0, {}, o), o.shared && o.shared.forEach((p) => {
    var y;
    const w = (y = c.shared) == null ? void 0 : y[p.sharedName];
    if (!w)
      return;
    const h = getRegisteredShare(t.shareScopeMap, p.sharedName, w, t.hooks.lifecycle.resolveShare);
    h && typeof h.lib == "function" && (p.assets.js.sync.forEach((M) => {
      u.add(M);
    }), p.assets.css.sync.forEach((M) => {
      l.add(M);
    }));
  });
  const g = s.filter((p) => !u.has(p));
  return {
    cssAssets: i.filter((p) => !l.has(p)),
    jsAssetsWithoutEntry: g,
    entryAssets: a
  };
}
const generatePreloadAssetsPlugin = function() {
  return {
    name: "generate-preload-assets-plugin",
    async generatePreloadAssets(t) {
      const { origin: e, preloadOptions: r, remoteInfo: n, remote: o, globalSnapshot: i, remoteSnapshot: s } = t;
      return isRemoteInfoWithEntry(o) && isPureRemoteEntry(o) ? {
        cssAssets: [],
        jsAssetsWithoutEntry: [],
        entryAssets: [
          {
            name: o.name,
            url: o.entry,
            moduleInfo: {
              name: n.name,
              entry: o.entry,
              type: "global",
              entryGlobalName: "",
              shareScope: ""
            }
          }
        ]
      } : (assignRemoteInfo(n, s), generatePreloadAssets(e, r, n, i, s));
    }
  };
};
function _extends$1() {
  return _extends$1 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, _extends$1.apply(this, arguments);
}
class SnapshotHandler {
  async loadSnapshot(e) {
    const { options: r } = this.HostInstance, { hostGlobalSnapshot: n, remoteSnapshot: o, globalSnapshot: i } = this.getGlobalRemoteInfo(e), { remoteSnapshot: s, globalSnapshot: a } = await this.hooks.lifecycle.loadSnapshot.emit({
      options: r,
      moduleInfo: e,
      hostGlobalSnapshot: n,
      remoteSnapshot: o,
      globalSnapshot: i
    });
    return {
      remoteSnapshot: s,
      globalSnapshot: a
    };
  }
  async loadRemoteSnapshotInfo(e) {
    const { options: r } = this.HostInstance;
    await this.hooks.lifecycle.beforeLoadRemoteSnapshot.emit({
      options: r,
      moduleInfo: e
    });
    let n = getGlobalSnapshotInfoByModuleInfo({
      name: this.HostInstance.options.name,
      version: this.HostInstance.options.version
    });
    n || (n = {
      version: this.HostInstance.options.version || "",
      remoteEntry: "",
      remotesInfo: {}
    }, addGlobalSnapshot({
      [this.HostInstance.options.name]: n
    })), n && "remotesInfo" in n && !getInfoWithoutType(n.remotesInfo, e.name).value && ("version" in e || "entry" in e) && (n.remotesInfo = _extends$1({}, n?.remotesInfo, {
      [e.name]: {
        matchedVersion: "version" in e ? e.version : e.entry
      }
    }));
    const { hostGlobalSnapshot: o, remoteSnapshot: i, globalSnapshot: s } = this.getGlobalRemoteInfo(e), { remoteSnapshot: a, globalSnapshot: u } = await this.hooks.lifecycle.loadSnapshot.emit({
      options: r,
      moduleInfo: e,
      hostGlobalSnapshot: o,
      remoteSnapshot: i,
      globalSnapshot: s
    });
    if (a)
      if (isManifestProvider(a)) {
        const l = await this.getManifestJson(a.remoteEntry, e, {}), c = setGlobalSnapshotInfoByModuleInfo(_extends$1({}, e, {
          entry: a.remoteEntry
        }), l);
        return {
          remoteSnapshot: l,
          globalSnapshot: c
        };
      } else {
        const { remoteSnapshot: l } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
          options: this.HostInstance.options,
          moduleInfo: e,
          remoteSnapshot: a,
          from: "global"
        });
        return {
          remoteSnapshot: l,
          globalSnapshot: u
        };
      }
    else if (isRemoteInfoWithEntry(e)) {
      const l = await this.getManifestJson(e.entry, e, {}), c = setGlobalSnapshotInfoByModuleInfo(e, l), { remoteSnapshot: d } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
        options: this.HostInstance.options,
        moduleInfo: e,
        remoteSnapshot: l,
        from: "global"
      });
      return {
        remoteSnapshot: d,
        globalSnapshot: c
      };
    } else
      error(`
          Cannot get remoteSnapshot with the name: '${e.name}', version: '${e.version}' from __FEDERATION__.moduleInfo. The following reasons may be causing the problem:

          1. The Deploy platform did not deliver the correct data. You can use __FEDERATION__.moduleInfo to check the remoteInfo.

          2. The remote '${e.name}' version '${e.version}' is not released.

          The transformed module info: ${JSON.stringify(u)}
        `);
  }
  getGlobalRemoteInfo(e) {
    const r = getGlobalSnapshotInfoByModuleInfo({
      name: this.HostInstance.options.name,
      version: this.HostInstance.options.version
    }), n = r && "remotesInfo" in r && r.remotesInfo && getInfoWithoutType(r.remotesInfo, e.name).value;
    return n && n.matchedVersion ? {
      hostGlobalSnapshot: r,
      globalSnapshot: getGlobalSnapshot(),
      remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({
        name: e.name,
        version: n.matchedVersion
      })
    } : {
      hostGlobalSnapshot: void 0,
      globalSnapshot: getGlobalSnapshot(),
      remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({
        name: e.name,
        version: "version" in e ? e.version : void 0
      })
    };
  }
  async getManifestJson(e, r, n) {
    const o = async () => {
      let s = this.manifestCache.get(e);
      if (s)
        return s;
      try {
        let a = await this.loaderHook.lifecycle.fetch.emit(e, {});
        return (!a || !(a instanceof Response)) && (a = await fetch(e, {})), s = await a.json(), assert(s.metaData && s.exposes && s.shared, `${e} is not a federation manifest`), this.manifestCache.set(e, s), s;
      } catch (a) {
        error(`Failed to get manifestJson for ${r.name}. The manifest URL is ${e}. Please ensure that the manifestUrl is accessible.
          
 Error message:
          
 ${a}`);
      }
    }, i = async () => {
      const s = await o(), a = generateSnapshotFromManifest(s, {
        version: e
      }), { remoteSnapshot: u } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
        options: this.HostInstance.options,
        moduleInfo: r,
        manifestJson: s,
        remoteSnapshot: a,
        manifestUrl: e,
        from: "manifest"
      });
      return u;
    };
    return this.manifestLoading[e] || (this.manifestLoading[e] = i().then((s) => s)), this.manifestLoading[e];
  }
  constructor(e) {
    this.loadingHostSnapshot = null, this.manifestCache = /* @__PURE__ */ new Map(), this.hooks = new PluginSystem({
      beforeLoadRemoteSnapshot: new AsyncHook("beforeLoadRemoteSnapshot"),
      loadSnapshot: new AsyncWaterfallHook("loadGlobalSnapshot"),
      loadRemoteSnapshot: new AsyncWaterfallHook("loadRemoteSnapshot")
    }), this.manifestLoading = Global.__FEDERATION__.__MANIFEST_LOADING__, this.HostInstance = e, this.loaderHook = e.loaderHook;
  }
}
function _extends() {
  return _extends = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, _extends.apply(this, arguments);
}
function _object_without_properties_loose(t, e) {
  if (t == null)
    return {};
  var r = {}, n = Object.keys(t), o, i;
  for (i = 0; i < n.length; i++)
    o = n[i], !(e.indexOf(o) >= 0) && (r[o] = t[o]);
  return r;
}
class FederationHost {
  _setGlobalShareScopeMap() {
    const e = getGlobalShareScope(), r = this.options.id || this.options.name;
    r && !e[r] && (e[r] = this.shareScopeMap);
  }
  initOptions(e) {
    this.registerPlugins(e.plugins);
    const r = this.formatOptions(this.options, e);
    return this.options = r, r;
  }
  async loadShare(e, r) {
    var n;
    const o = Object.assign({}, (n = this.options.shared) == null ? void 0 : n[e], r);
    o != null && o.scope && await Promise.all(o.scope.map(async (l) => {
      await Promise.all(this.initializeSharing(l, o.strategy));
    }));
    const i = await this.hooks.lifecycle.beforeLoadShare.emit({
      pkgName: e,
      shareInfo: o,
      shared: this.options.shared,
      origin: this
    }), { shareInfo: s } = i;
    assert(s, `Cannot find ${e} Share in the ${this.options.name}. Please ensure that the ${e} Share parameters have been injected`);
    const a = getRegisteredShare(this.shareScopeMap, e, s, this.hooks.lifecycle.resolveShare), u = (l) => {
      l.useIn || (l.useIn = []), addUniqueItem(l.useIn, this.options.name);
    };
    if (a && a.lib)
      return u(a), a.lib;
    if (a && a.loading && !a.loaded) {
      const l = await a.loading;
      return a.loaded = !0, a.lib || (a.lib = l), u(a), l;
    } else if (a) {
      const l = (async () => {
        const c = await a.get();
        s.lib = c, s.loaded = !0, u(s);
        const d = getRegisteredShare(this.shareScopeMap, e, s, this.hooks.lifecycle.resolveShare);
        return d && (d.lib = c, d.loaded = !0), c;
      })();
      return this.setShared({
        pkgName: e,
        loaded: !1,
        shared: a,
        from: this.options.name,
        lib: null,
        loading: l
      }), l;
    } else {
      if (r)
        return !1;
      const l = (async () => {
        const c = await s.get();
        s.lib = c, s.loaded = !0, u(s);
        const d = getRegisteredShare(this.shareScopeMap, e, s, this.hooks.lifecycle.resolveShare);
        return d && (d.lib = c, d.loaded = !0), c;
      })();
      return this.setShared({
        pkgName: e,
        loaded: !1,
        shared: s,
        from: this.options.name,
        lib: null,
        loading: l
      }), l;
    }
  }
  loadShareSync(e, r) {
    var n;
    const o = Object.assign({}, (n = this.options.shared) == null ? void 0 : n[e], r);
    o != null && o.scope && o.scope.forEach((a) => {
      this.initializeSharing(a, o.strategy);
    });
    const i = getRegisteredShare(this.shareScopeMap, e, o, this.hooks.lifecycle.resolveShare), s = (a) => {
      a.useIn || (a.useIn = []), addUniqueItem(a.useIn, this.options.name);
    };
    if (i) {
      if (typeof i.lib == "function")
        return s(i), i.loaded || (i.loaded = !0, i.from === this.options.name && (o.loaded = !0)), i.lib;
      if (typeof i.get == "function") {
        const a = i.get();
        if (!(a instanceof Promise))
          return s(i), this.setShared({
            pkgName: e,
            loaded: !0,
            from: this.options.name,
            lib: a,
            shared: i
          }), a;
      }
    }
    if (o.lib)
      return o.loaded || (o.loaded = !0), o.lib;
    if (o.get) {
      const a = o.get();
      if (a instanceof Promise)
        throw new Error(`
        The loadShareSync function was unable to load ${e}. The ${e} could not be found in ${this.options.name}.
        Possible reasons for failure: 

        1. The ${e} share was registered with the 'get' attribute, but loadShare was not used beforehand.

        2. The ${e} share was not registered with the 'lib' attribute.

      `);
      return o.lib = a, this.setShared({
        pkgName: e,
        loaded: !0,
        from: this.options.name,
        lib: o.lib,
        shared: o
      }), o.lib;
    }
    throw new Error(`
        The loadShareSync function was unable to load ${e}. The ${e} could not be found in ${this.options.name}.
        Possible reasons for failure: 

        1. The ${e} share was registered with the 'get' attribute, but loadShare was not used beforehand.

        2. The ${e} share was not registered with the 'lib' attribute.

      `);
  }
  initRawContainer(e, r, n) {
    const o = getRemoteInfo({
      name: e,
      entry: r
    }), i = new Module({
      host: this,
      remoteInfo: o
    });
    return i.remoteEntryExports = n, this.moduleCache.set(e, i), i;
  }
  async _getRemoteModuleAndOptions(e) {
    const r = await this.hooks.lifecycle.beforeRequest.emit({
      id: e,
      options: this.options,
      origin: this
    }), { id: n } = r, o = matchRemoteWithNameAndExpose(this.options.remotes, n);
    assert(o, `
        Unable to locate ${n} in ${this.options.name}. Potential reasons for failure include:

        1. ${n} was not included in the 'remotes' parameter of ${this.options.name || "the host"}.

        2. ${n} could not be found in the 'remotes' of ${this.options.name} with either 'name' or 'alias' attributes.
        3. ${n} is not online, injected, or loaded.
        4. ${n}  cannot be accessed on the expected.
        5. The 'beforeRequest' hook was provided but did not return the correct 'remoteInfo' when attempting to load ${n}.
      `);
    const { remote: i } = o, s = getRemoteInfo(i), a = await this.hooks.lifecycle.afterResolve.emit(_extends({
      id: n
    }, o, {
      options: this.options,
      origin: this,
      remoteInfo: s
    })), { remote: u, expose: l } = a;
    assert(u && l, `The 'beforeRequest' hook was executed, but it failed to return the correct 'remote' and 'expose' values while loading ${n}.`);
    let c = this.moduleCache.get(u.name);
    const d = {
      host: this,
      remoteInfo: s
    };
    return c || (c = new Module(d), this.moduleCache.set(u.name, c)), {
      module: c,
      moduleOptions: d,
      remoteMatchInfo: a
    };
  }
  async loadRemote(e, r) {
    try {
      const { loadFactory: n = !0 } = r || {
        loadFactory: !0
      }, { module: o, moduleOptions: i, remoteMatchInfo: s } = await this._getRemoteModuleAndOptions(e), { pkgNameOrAlias: a, remote: u, expose: l, id: c } = s, d = await o.get(l, r), m = await this.hooks.lifecycle.onLoad.emit({
        id: c,
        pkgNameOrAlias: a,
        expose: l,
        exposeModule: n ? d : void 0,
        exposeModuleFactory: n ? void 0 : d,
        remote: u,
        options: i,
        moduleInstance: o,
        origin: this
      });
      return typeof m == "function" ? m : d;
    } catch (n) {
      const { from: o = "runtime" } = r || {
        from: "runtime"
      }, i = await this.hooks.lifecycle.errorLoadRemote.emit({
        id: e,
        error: n,
        from: o,
        origin: this
      });
      if (!i)
        throw n;
      return i;
    }
  }
  async preloadRemote(e) {
    await this.hooks.lifecycle.beforePreloadRemote.emit({
      preloadOptions: e,
      options: this.options,
      origin: this
    });
    const r = formatPreloadArgs(this.options.remotes, e);
    await Promise.all(r.map(async (n) => {
      const { remote: o } = n, i = getRemoteInfo(o), { globalSnapshot: s, remoteSnapshot: a } = await this.snapshotHandler.loadRemoteSnapshotInfo(o), u = await this.hooks.lifecycle.generatePreloadAssets.emit({
        origin: this,
        preloadOptions: n,
        remote: o,
        remoteInfo: i,
        globalSnapshot: s,
        remoteSnapshot: a
      });
      !u || preloadAssets(i, this, u);
    }));
  }
  initializeSharing(e = DEFAULT_SCOPE, r) {
    const n = this.shareScopeMap, o = this.options.name;
    n[e] || (n[e] = {});
    const i = n[e], s = (c, d) => {
      var m;
      const { version: g, eager: p } = d;
      i[c] = i[c] || {};
      const y = i[c], w = y[g], h = !!(w && (w.eager || (m = w.shareConfig) != null && m.eager));
      (!w || w.strategy !== "loaded-first" && !w.loaded && (!p != !h ? p : o > w.from)) && (y[g] = d);
    }, a = [], u = (c) => c && c.init && c.init(n[e]), l = async (c) => {
      const { module: d } = await this._getRemoteModuleAndOptions(c);
      if (d.getEntry) {
        const m = await d.getEntry();
        d.inited || (u(m), d.inited = !0);
      }
    };
    return Object.keys(this.options.shared).forEach((c) => {
      const d = this.options.shared[c];
      d.scope.includes(e) && s(c, d);
    }), r === "version-first" && this.options.remotes.forEach((c) => {
      c.shareScope === e && a.push(l(c.name));
    }), a;
  }
  initShareScopeMap(e, r) {
    this.shareScopeMap[e] = r, this.hooks.lifecycle.initContainerShareScopeMap.emit({
      shareScope: r,
      options: this.options,
      origin: this
    });
  }
  formatOptions(e, r) {
    const n = formatShareConfigs(r.shared || {}, r.name), o = _extends({}, e.shared, n), { userOptions: i, options: s } = this.hooks.lifecycle.beforeInit.emit({
      origin: this,
      userOptions: r,
      options: e,
      shareInfo: o
    }), a = (i.remotes || []).reduce((c, d) => (this.registerRemote(d, c, {
      force: !1
    }), c), s.remotes);
    Object.keys(n).forEach((c) => {
      const d = n[c];
      !getRegisteredShare(this.shareScopeMap, c, d, this.hooks.lifecycle.resolveShare) && d && d.lib && this.setShared({
        pkgName: c,
        lib: d.lib,
        get: d.get,
        loaded: !0,
        shared: d,
        from: r.name
      });
    });
    const u = [
      ...s.plugins
    ];
    i.plugins && i.plugins.forEach((c) => {
      u.includes(c) || u.push(c);
    });
    const l = _extends({}, e, r, {
      plugins: u,
      remotes: a,
      shared: o
    });
    return this.hooks.lifecycle.init.emit({
      origin: this,
      options: l
    }), l;
  }
  registerPlugins(e) {
    registerPlugins(e, [
      this.hooks,
      this.snapshotHandler.hooks,
      this.loaderHook
    ]);
  }
  setShared({ pkgName: e, shared: r, from: n, lib: o, loading: i, loaded: s, get: a }) {
    const { version: u, scope: l = "default" } = r, c = _object_without_properties_loose(r, [
      "version",
      "scope"
    ]);
    (Array.isArray(l) ? l : [
      l
    ]).forEach((d) => {
      this.shareScopeMap[d] || (this.shareScopeMap[d] = {}), this.shareScopeMap[d][e] || (this.shareScopeMap[d][e] = {}), !this.shareScopeMap[d][e][u] && (this.shareScopeMap[d][e][u] = _extends({
        version: u,
        scope: [
          "default"
        ]
      }, c, {
        lib: o,
        loaded: s,
        loading: i
      }), a && (this.shareScopeMap[d][e][u].get = a));
    });
  }
  removeRemote(e) {
    const { name: r } = e, n = this.options.remotes.findIndex((i) => i.name === r);
    n !== -1 && this.options.remotes.splice(n, 1);
    const o = this.moduleCache.get(e.name);
    if (o) {
      const i = o.remoteInfo.entryGlobalName;
      globalThis[i] && delete globalThis[i];
      const s = getRemoteEntryUniqueKey(o.remoteInfo);
      globalLoading[s] && delete globalLoading[s], this.moduleCache.delete(e.name);
    }
  }
  registerRemote(e, r, n) {
    const o = () => {
      if (e.alias) {
        const s = r.find((a) => {
          var u;
          return e.alias && (a.name.startsWith(e.alias) || ((u = a.alias) == null ? void 0 : u.startsWith(e.alias)));
        });
        assert(!s, `The alias ${e.alias} of remote ${e.name} is not allowed to be the prefix of ${s && s.name} name or alias`);
      }
      "entry" in e && isBrowserEnv$1() && !e.entry.startsWith("http") && (e.entry = new URL(e.entry, window.location.origin).href), e.shareScope || (e.shareScope = DEFAULT_SCOPE), e.type || (e.type = DEFAULT_REMOTE_TYPE);
    }, i = r.find((s) => s.name === e.name);
    if (!i)
      o(), r.push(e);
    else {
      const s = [
        `The remote "${e.name}" is already registered.`,
        n != null && n.force ? "Hope you have known that OVERRIDE it may have some unexpected errors" : 'If you want to merge the remote, you can set "force: true".'
      ];
      n != null && n.force && (this.removeRemote(i), o(), r.push(e)), warn$1(s.join(" "));
    }
  }
  registerRemotes(e, r) {
    e.forEach((n) => {
      this.registerRemote(n, this.options.remotes, {
        force: r?.force
      });
    });
  }
  constructor(e) {
    this.hooks = new PluginSystem({
      beforeInit: new SyncWaterfallHook("beforeInit"),
      init: new SyncHook(),
      beforeRequest: new AsyncWaterfallHook("beforeRequest"),
      afterResolve: new AsyncWaterfallHook("afterResolve"),
      beforeInitContainer: new AsyncWaterfallHook("beforeInitContainer"),
      initContainerShareScopeMap: new AsyncWaterfallHook("initContainer"),
      initContainer: new AsyncWaterfallHook("initContainer"),
      onLoad: new AsyncHook("onLoad"),
      handlePreloadModule: new SyncHook("handlePreloadModule"),
      errorLoadRemote: new AsyncHook("errorLoadRemote"),
      beforeLoadShare: new AsyncWaterfallHook("beforeLoadShare"),
      loadShare: new AsyncHook(),
      resolveShare: new SyncWaterfallHook("resolveShare"),
      beforePreloadRemote: new AsyncHook(),
      generatePreloadAssets: new AsyncHook("generatePreloadAssets"),
      afterPreloadRemote: new AsyncHook()
    }), this.version = "0.1.2", this.moduleCache = /* @__PURE__ */ new Map(), this.loaderHook = new PluginSystem({
      getModuleInfo: new SyncHook(),
      createScript: new SyncHook(),
      createLink: new SyncHook(),
      fetch: new AsyncHook("fetch")
    });
    const r = {
      id: getBuilderId(),
      name: e.name,
      plugins: [
        snapshotPlugin(),
        generatePreloadAssetsPlugin()
      ],
      remotes: [],
      shared: {},
      inBrowser: isBrowserEnv$1()
    };
    this.name = e.name, this.options = r, this.shareScopeMap = {}, this._setGlobalShareScopeMap(), this.snapshotHandler = new SnapshotHandler(this), this.registerPlugins([
      ...r.plugins,
      ...e.plugins || []
    ]), this.options = this.formatOptions(r, e);
  }
}
let FederationInstance = null;
function init$1(t) {
  const e = getGlobalFederationInstance(t.name, t.version);
  if (e)
    return e.initOptions(t), FederationInstance || (FederationInstance = e), e;
  {
    const r = getGlobalFederationConstructor() || FederationHost;
    return FederationInstance = new r(t), setGlobalFederationInstance(FederationInstance), FederationInstance;
  }
}
function loadRemote(...t) {
  return assert(FederationInstance, "Please call init first"), FederationInstance.loadRemote.apply(FederationInstance, t);
}
setGlobalFederationConstructor(FederationHost);
function __awaiter(t, e, r, n) {
  function o(i) {
    return i instanceof r ? i : new r(function(s) {
      s(i);
    });
  }
  return new (r || (r = Promise))(function(i, s) {
    function a(c) {
      try {
        l(n.next(c));
      } catch (d) {
        s(d);
      }
    }
    function u(c) {
      try {
        l(n.throw(c));
      } catch (d) {
        s(d);
      }
    }
    function l(c) {
      c.done ? i(c.value) : o(c.value).then(a, u);
    }
    l((n = n.apply(t, e || [])).next());
  });
}
function __generator(t, e) {
  var r = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, o, i, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(l) {
    return function(c) {
      return u([l, c]);
    };
  }
  function u(l) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (n = 1, o && (i = l[0] & 2 ? o.return : l[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, l[1])).done)
          return i;
        switch (o = 0, i && (l = [l[0] & 2, i.value]), l[0]) {
          case 0:
          case 1:
            i = l;
            break;
          case 4:
            return r.label++, { value: l[1], done: !1 };
          case 5:
            r.label++, o = l[1], l = [0];
            continue;
          case 7:
            l = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (i = r.trys, !(i = i.length > 0 && i[i.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              r = 0;
              continue;
            }
            if (l[0] === 3 && (!i || l[1] > i[0] && l[1] < i[3])) {
              r.label = l[1];
              break;
            }
            if (l[0] === 6 && r.label < i[1]) {
              r.label = i[1], i = l;
              break;
            }
            if (i && r.label < i[2]) {
              r.label = i[2], r.ops.push(l);
              break;
            }
            i[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        l = e.call(t, r);
      } catch (c) {
        l = [6, c], o = 0;
      } finally {
        n = i = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
var E_CANCELED = new Error("request for lock canceled"), Semaphore = function() {
  function t(e, r) {
    r === void 0 && (r = E_CANCELED), this._value = e, this._cancelError = r, this._queue = [], this._weightedWaiters = [];
  }
  return t.prototype.acquire = function(e, r) {
    var n = this;
    if (e === void 0 && (e = 1), r === void 0 && (r = 0), e <= 0)
      throw new Error("invalid weight ".concat(e, ": must be positive"));
    return new Promise(function(o, i) {
      var s = { resolve: o, reject: i, weight: e, priority: r }, a = findIndexFromEnd(n._queue, function(u) {
        return r <= u.priority;
      });
      a === -1 && e <= n._value ? n._dispatchItem(s) : n._queue.splice(a + 1, 0, s);
    });
  }, t.prototype.runExclusive = function(e) {
    return __awaiter(this, arguments, void 0, function(r, n, o) {
      var i, s, a;
      return n === void 0 && (n = 1), o === void 0 && (o = 0), __generator(this, function(u) {
        switch (u.label) {
          case 0:
            return [4, this.acquire(n, o)];
          case 1:
            i = u.sent(), s = i[0], a = i[1], u.label = 2;
          case 2:
            return u.trys.push([2, , 4, 5]), [4, r(s)];
          case 3:
            return [2, u.sent()];
          case 4:
            return a(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, t.prototype.waitForUnlock = function(e, r) {
    var n = this;
    if (e === void 0 && (e = 1), r === void 0 && (r = 0), e <= 0)
      throw new Error("invalid weight ".concat(e, ": must be positive"));
    return this._couldLockImmediately(e, r) ? Promise.resolve() : new Promise(function(o) {
      n._weightedWaiters[e - 1] || (n._weightedWaiters[e - 1] = []), insertSorted(n._weightedWaiters[e - 1], { resolve: o, priority: r });
    });
  }, t.prototype.isLocked = function() {
    return this._value <= 0;
  }, t.prototype.getValue = function() {
    return this._value;
  }, t.prototype.setValue = function(e) {
    this._value = e, this._dispatchQueue();
  }, t.prototype.release = function(e) {
    if (e === void 0 && (e = 1), e <= 0)
      throw new Error("invalid weight ".concat(e, ": must be positive"));
    this._value += e, this._dispatchQueue();
  }, t.prototype.cancel = function() {
    var e = this;
    this._queue.forEach(function(r) {
      return r.reject(e._cancelError);
    }), this._queue = [];
  }, t.prototype._dispatchQueue = function() {
    for (this._drainUnlockWaiters(); this._queue.length > 0 && this._queue[0].weight <= this._value; )
      this._dispatchItem(this._queue.shift()), this._drainUnlockWaiters();
  }, t.prototype._dispatchItem = function(e) {
    var r = this._value;
    this._value -= e.weight, e.resolve([r, this._newReleaser(e.weight)]);
  }, t.prototype._newReleaser = function(e) {
    var r = this, n = !1;
    return function() {
      n || (n = !0, r.release(e));
    };
  }, t.prototype._drainUnlockWaiters = function() {
    if (this._queue.length === 0)
      for (var e = this._value; e > 0; e--) {
        var r = this._weightedWaiters[e - 1];
        !r || (r.forEach(function(i) {
          return i.resolve();
        }), this._weightedWaiters[e - 1] = []);
      }
    else
      for (var n = this._queue[0].priority, e = this._value; e > 0; e--) {
        var r = this._weightedWaiters[e - 1];
        if (r) {
          var o = r.findIndex(function(a) {
            return a.priority <= n;
          });
          (o === -1 ? r : r.splice(0, o)).forEach(function(a) {
            return a.resolve();
          });
        }
      }
  }, t.prototype._couldLockImmediately = function(e, r) {
    return (this._queue.length === 0 || this._queue[0].priority < r) && e <= this._value;
  }, t;
}();
function insertSorted(t, e) {
  var r = findIndexFromEnd(t, function(n) {
    return e.priority <= n.priority;
  });
  t.splice(r + 1, 0, e);
}
function findIndexFromEnd(t, e) {
  for (var r = t.length - 1; r >= 0; r--)
    if (e(t[r]))
      return r;
  return -1;
}
var Mutex = function() {
  function t(e) {
    this._semaphore = new Semaphore(1, e);
  }
  return t.prototype.acquire = function() {
    return __awaiter(this, arguments, void 0, function(e) {
      var r, n;
      return e === void 0 && (e = 0), __generator(this, function(o) {
        switch (o.label) {
          case 0:
            return [4, this._semaphore.acquire(1, e)];
          case 1:
            return r = o.sent(), n = r[1], [2, n];
        }
      });
    });
  }, t.prototype.runExclusive = function(e, r) {
    return r === void 0 && (r = 0), this._semaphore.runExclusive(function() {
      return e();
    }, 1, r);
  }, t.prototype.isLocked = function() {
    return this._semaphore.isLocked();
  }, t.prototype.waitForUnlock = function(e) {
    return e === void 0 && (e = 0), this._semaphore.waitForUnlock(1, e);
  }, t.prototype.release = function() {
    this._semaphore.isLocked() && this._semaphore.release();
  }, t.prototype.cancel = function() {
    return this._semaphore.cancel();
  }, t;
}();
function isMetaMaskProvider(t) {
  return t !== null && typeof t == "object" && t.hasOwnProperty("isMetaMask") && t.hasOwnProperty("request");
}
function detectMetaMaskProvider(t, { timeout: e = 3e3 } = {}) {
  let r = !1;
  return new Promise((n) => {
    const o = (i) => {
      const { info: s, provider: a } = i.detail;
      (s.rdns === "io.metamask" || s.rdns === "io.metamask.flask") && isMetaMaskProvider(a) && (n(a), r = !0);
    };
    typeof t.addEventListener == "function" && t.addEventListener(
      "eip6963:announceProvider",
      o
    ), setTimeout(() => {
      r || n(null);
    }, e), typeof t.dispatchEvent == "function" && t.dispatchEvent(new Event("eip6963:requestProvider"));
  });
}
async function waitForMetaMaskProvider(t, e = {}) {
  const { timeout: r = 3e3, retries: n = 0 } = e;
  let o = null;
  try {
    o = await detectMetaMaskProvider(t, { timeout: r });
  } catch {
  }
  return o || (n === 0 ? null : (o = await waitForMetaMaskProvider({ timeout: r, retries: n - 1 }), o));
}
async function detectMetamaskSupport(t) {
  return await waitForMetaMaskProvider(t, { retries: 3 });
}
var H, K;
class MetaMaskVirtualWallet {
  constructor() {
    x(this, H), O(this, "id", "metamask"), O(this, "name", "MetaMask"), O(this, "icon", "data:image/svg+xml;utf8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMTIiIGhlaWdodD0iMTg5IiB2aWV3Qm94PSIwIDAgMjEyIDE4OSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cG9seWdvbiBmaWxsPSIjQ0RCREIyIiBwb2ludHM9IjYwLjc1IDE3My4yNSA4OC4zMTMgMTgwLjU2MyA4OC4zMTMgMTcxIDkwLjU2MyAxNjguNzUgMTA2LjMxMyAxNjguNzUgMTA2LjMxMyAxODAgMTA2LjMxMyAxODcuODc1IDg5LjQzOCAxODcuODc1IDY4LjYyNSAxNzguODc1Ii8+PHBvbHlnb24gZmlsbD0iI0NEQkRCMiIgcG9pbnRzPSIxMDUuNzUgMTczLjI1IDEzMi43NSAxODAuNTYzIDEzMi43NSAxNzEgMTM1IDE2OC43NSAxNTAuNzUgMTY4Ljc1IDE1MC43NSAxODAgMTUwLjc1IDE4Ny44NzUgMTMzLjg3NSAxODcuODc1IDExMy4wNjMgMTc4Ljg3NSIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjU2LjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzEgOTEuMTI1IDE2OC43NSAxMjAuMzc1IDE2OC43NSAxMjMuNzUgMTcxIDEyMS41IDE1Mi40MzggMTE3IDE0OS42MjUgOTQuNSAxNTAuMTg4Ii8+PHBvbHlnb24gZmlsbD0iI0Y4OUMzNSIgcG9pbnRzPSI3NS4zNzUgMjcgODguODc1IDU4LjUgOTUuMDYzIDE1MC4xODggMTE3IDE1MC4xODggMTIzLjc1IDU4LjUgMTM2LjEyNSAyNyIvPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MC41NjMgMTUyLjQzOCIvPjxwb2x5Z29uIGZpbGw9IiNFQThFM0EiIHBvaW50cz0iOTIuMjUgMTAyLjM3NSA5NS4wNjMgMTUwLjE4OCA4Ni42MjUgMTI1LjcxOSIvPjxwb2x5Z29uIGZpbGw9IiNEODdDMzAiIHBvaW50cz0iMzkuMzc1IDEzOC45MzggNjUuMjUgMTM4LjM3NSA2MC43NSAxNzMuMjUiLz48cG9seWdvbiBmaWxsPSIjRUI4RjM1IiBwb2ludHM9IjEyLjkzOCAxODguNDM4IDYwLjc1IDE3My4yNSAzOS4zNzUgMTM4LjkzOCAuNTYzIDE0MS43NSIvPjxwb2x5Z29uIGZpbGw9IiNFODgyMUUiIHBvaW50cz0iODguODc1IDU4LjUgNjQuNjg4IDc4Ljc1IDQ2LjEyNSAxMDEuMjUgOTIuMjUgMTAyLjkzOCIvPjxwb2x5Z29uIGZpbGw9IiNERkNFQzMiIHBvaW50cz0iNjAuNzUgMTczLjI1IDkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzAuNDM4IDg4LjMxMyAxODAuNTYzIDY4LjA2MyAxNzYuNjI1Ii8+PHBvbHlnb24gZmlsbD0iI0RGQ0VDMyIgcG9pbnRzPSIxMjEuNSAxNzMuMjUgMTUwLjc1IDE1Mi40MzggMTQ4LjUgMTcwLjQzOCAxNDguNSAxODAuNTYzIDEyOC4yNSAxNzYuNjI1IiB0cmFuc2Zvcm09Im1hdHJpeCgtMSAwIDAgMSAyNzIuMjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PGcgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjExLjUgMCkiPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MCAxNTMiLz48cG9seWdvbiBmaWxsPSIjRUE4RTNBIiBwb2ludHM9IjkyLjI1IDEwMi4zNzUgOTUuMDYzIDE1MC4xODggODYuNjI1IDEyNS43MTkiLz48cG9seWdvbiBmaWxsPSIjRDg3QzMwIiBwb2ludHM9IjM5LjM3NSAxMzguOTM4IDY1LjI1IDEzOC4zNzUgNjAuNzUgMTczLjI1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSIxMi45MzggMTg4LjQzOCA2MC43NSAxNzMuMjUgMzkuMzc1IDEzOC45MzggLjU2MyAxNDEuNzUiLz48cG9seWdvbiBmaWxsPSIjRTg4MjFFIiBwb2ludHM9Ijg4Ljg3NSA1OC41IDY0LjY4OCA3OC43NSA0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi45MzgiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PC9nPjwvZz48L3N2Zz4="), O(this, "windowKey", "starknet_metamask"), O(this, "provider", null), O(this, "swo", null), O(this, "lock"), this.lock = new Mutex();
  }
  async loadWallet(e) {
    this.provider || (this.provider = await detectMetamaskSupport(e)), await init$1({
      name: "MetaMaskStarknetSnapWallet",
      remotes: [
        {
          name: "MetaMaskStarknetSnapWallet",
          alias: "MetaMaskStarknetSnapWallet",
          entry: "https://snaps.consensys.io/starknet/get-starknet/v1/remoteEntry.js"
        }
      ]
    });
    const r = await loadRemote("MetaMaskStarknetSnapWallet/index");
    if (!r)
      throw new Error("Failed to load MetaMask Wallet");
    return new r.MetaMaskSnapWallet(
      this.provider,
      "*"
    );
  }
  async hasSupport(e) {
    return this.provider = await detectMetamaskSupport(e), this.provider !== null;
  }
  async request(e) {
    const { type: r } = e;
    switch (r) {
      case "wallet_supportedWalletApi":
        return ["0.7"];
      case "wallet_supportedSpecs":
        return ["0.7"];
      default:
        return C(this, H, K).call(this, e);
    }
  }
  on() {
  }
  off() {
  }
}
H = /* @__PURE__ */ new WeakSet(), K = async function(t) {
  return this.lock.runExclusive(async () => (this.swo || (this.swo = await this.loadWallet(window)), this.swo.request(t)));
};
const metaMaskVirtualWallet = new MetaMaskVirtualWallet();
var V, $;
const wallets = [
  {
    id: "argentX",
    name: "Argent X",
    icon: "data:image/svg+xml;base64,Cjxzdmcgd2lkdGg9IjQwIiBoZWlnaHQ9IjM2IiB2aWV3Qm94PSIwIDAgNDAgMzYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0yNC43NTgyIC0zLjk3MzY0ZS0wN0gxNC42MjM4QzE0LjI4NTEgLTMuOTczNjRlLTA3IDE0LjAxMzggMC4yODExNzggMTQuMDA2NCAwLjYzMDY4M0MxMy44MDE3IDEwLjQ1NDkgOC44MjIzNCAxOS43NzkyIDAuMjUxODkzIDI2LjM4MzdDLTAuMDIwMjA0NiAyNi41OTMzIC0wLjA4MjE5NDYgMjYuOTg3MiAwLjExNjczNCAyNy4yNzA5TDYuMDQ2MjMgMzUuNzM0QzYuMjQ3OTYgMzYuMDIyIDYuNjQwOTkgMzYuMDg3IDYuOTE3NjYgMzUuODc1NEMxMi4yNzY1IDMxLjc3MjggMTYuNTg2OSAyNi44MjM2IDE5LjY5MSAyMS4zMzhDMjIuNzk1MSAyNi44MjM2IDI3LjEwNTcgMzEuNzcyOCAzMi40NjQ2IDM1Ljg3NTRDMzIuNzQxIDM2LjA4NyAzMy4xMzQxIDM2LjAyMiAzMy4zMzYxIDM1LjczNEwzOS4yNjU2IDI3LjI3MDlDMzkuNDY0MiAyNi45ODcyIDM5LjQwMjIgMjYuNTkzMyAzOS4xMzA0IDI2LjM4MzdDMzAuNTU5NyAxOS43NzkyIDI1LjU4MDQgMTAuNDU0OSAyNS4zNzU5IDAuNjMwNjgzQzI1LjM2ODUgMC4yODExNzggMjUuMDk2OSAtMy45NzM2NGUtMDcgMjQuNzU4MiAtMy45NzM2NGUtMDdaIiBmaWxsPSIjRkY4NzVCIi8+Cjwvc3ZnPgo=",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/argent-x-starknet-wallet/dlcobpjiigpikoobohmabehhmhfoodbb",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/argent-x",
      edge: "https://microsoftedge.microsoft.com/addons/detail/argent-x/ajcicjlkibolbeaaagejfhnofogocgcj"
    }
  },
  {
    id: "braavos",
    name: "Braavos",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8cGF0aAogICAgICAgIGQ9Ik02Mi43MDUgMTMuOTExNkM2Mi44MzU5IDE0LjEzMzMgNjIuNjYyMSAxNC40MDcgNjIuNDAzOSAxNC40MDdDNTcuMTgwNyAxNC40MDcgNTIuOTM0OCAxOC41NDI3IDUyLjgzNTEgMjMuNjgxN0M1MS4wNDY1IDIzLjM0NzcgNDkuMTkzMyAyMy4zMjI2IDQ3LjM2MjYgMjMuNjMxMUM0Ny4yMzYxIDE4LjUxNTYgNDMuMDAwOSAxNC40MDcgMzcuNzk0OCAxNC40MDdDMzcuNTM2NSAxNC40MDcgMzcuMzYyNSAxNC4xMzMxIDM3LjQ5MzUgMTMuOTExMkM0MC4wMjE3IDkuNjI4MDkgNDQuNzIwNCA2Ljc1IDUwLjA5OTEgNi43NUM1NS40NzgxIDYuNzUgNjAuMTc2OSA5LjYyODI2IDYyLjcwNSAxMy45MTE2WiIKICAgICAgICBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMzcyXzQwMjU5KSIgLz4KICAgIDxwYXRoCiAgICAgICAgZD0iTTc4Ljc2MDYgNDUuODcxOEM4MC4yNzI1IDQ2LjMyOTcgODEuNzAyNSA0NS4wMDU1IDgxLjE3MTQgNDMuNTIyMkM3Ni40MTM3IDMwLjIzMzQgNjEuMzkxMSAyNC44MDM5IDUwLjAyNzcgMjQuODAzOUMzOC42NDQyIDI0LjgwMzkgMjMuMjg2OCAzMC40MDcgMTguODc1NCA0My41OTEyQzE4LjM4MjQgNDUuMDY0NSAxOS44MDgzIDQ2LjM0NDYgMjEuMjk3OCA0NS44ODgxTDQ4Ljg3MiAzNy40MzgxQzQ5LjUzMzEgMzcuMjM1NSA1MC4yMzk5IDM3LjIzNDQgNTAuOTAxNyAzNy40MzQ4TDc4Ljc2MDYgNDUuODcxOFoiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8cGF0aAogICAgICAgIGQ9Ik0xOC44MTMyIDQ4LjE3MDdMNDguODkzNSAzOS4wNDcyQzQ5LjU1MDYgMzguODQ3OCA1MC4yNTI0IDM4Ljg0NzMgNTAuOTA5OCAzOS4wNDU2TDgxLjE3ODEgNDguMTc1MkM4My42OTEyIDQ4LjkzMzIgODUuNDExIDUxLjI0ODMgODUuNDExIDUzLjg3MzVWODEuMjIzM0M4NS4yOTQ0IDg3Ljg5OTEgNzkuMjk3NyA5My4yNSA3Mi42MjQ1IDkzLjI1SDYxLjU0MDZDNjAuNDQ0OSA5My4yNSA1OS41NTc3IDkyLjM2MzcgNTkuNTU3NyA5MS4yNjhWODEuNjc4OUM1OS41NTc3IDc3LjkwMzEgNjEuNzkyMSA3NC40ODU1IDY1LjI0OTggNzIuOTcyOUM2OS44ODQ5IDcwLjk0NTQgNzUuMzY4MSA2OC4yMDI4IDc2LjM5OTQgNjIuNjk5MkM3Ni43MzIzIDYwLjkyMjkgNzUuNTc0MSA1OS4yMDk0IDczLjgwMjQgNTguODU3M0M2OS4zMjI2IDU3Ljk2NjcgNjQuMzU2MiA1OC4zMTA3IDYwLjE1NjQgNjAuMTg5M0M1NS4zODg3IDYyLjMyMTkgNTQuMTQxNSA2NS44Njk0IDUzLjY3OTcgNzAuNjMzN0w1My4xMjAxIDc1Ljc2NjJDNTIuOTQ5MSA3Ny4zMzQ5IDUxLjQ3ODUgNzguNTM2NiA0OS45MDE0IDc4LjUzNjZDNDguMjY5OSA3OC41MzY2IDQ3LjA0NjUgNzcuMjk0IDQ2Ljg2OTYgNzUuNjcxMkw0Ni4zMjA0IDcwLjYzMzdDNDUuOTI0OSA2Ni41NTI5IDQ1LjIwNzkgNjIuNTg4NyA0MC45ODk1IDYwLjcwMThDMzYuMTc3NiA1OC41NDk0IDMxLjM0MTkgNTcuODM0NyAyNi4xOTc2IDU4Ljg1NzNDMjQuNDI2IDU5LjIwOTQgMjMuMjY3OCA2MC45MjI5IDIzLjYwMDcgNjIuNjk5MkMyNC42NDEgNjguMjUwNyAzMC4wODEyIDcwLjkzMDUgMzQuNzUwMyA3Mi45NzI5QzM4LjIwOCA3NC40ODU1IDQwLjQ0MjQgNzcuOTAzMSA0MC40NDI0IDgxLjY3ODlWOTEuMjY2M0M0MC40NDI0IDkyLjM2MiAzOS41NTU1IDkzLjI1IDM4LjQ1OTkgOTMuMjVIMjcuMzc1NkMyMC43MDI0IDkzLjI1IDE0LjcwNTcgODcuODk5MSAxNC41ODkxIDgxLjIyMzNWNTMuODY2M0MxNC41ODkxIDUxLjI0NDYgMTYuMzA0NSA0OC45MzE2IDE4LjgxMzIgNDguMTcwN1oiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDJfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8ZGVmcz4KICAgICAgICA8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMzcyXzQwMjU5IiB4MT0iNDkuMzA1NyIgeTE9IjIuMDc5IiB4Mj0iODAuMzYyNyIgeTI9IjkzLjY1OTciCiAgICAgICAgICAgIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIgLz4KICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5NjAwIiAvPgogICAgICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICAgICAgPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzM3Ml80MDI1OSIgeDE9IjQ5LjMwNTciIHkxPSIyLjA3OSIgeDI9IjgwLjM2MjciIHkyPSI5My42NTk3IgogICAgICAgICAgICBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgICAgICAgIDxzdG9wIHN0b3AtY29sb3I9IiNGNUQ0NUUiIC8+CiAgICAgICAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGOTYwMCIgLz4KICAgICAgICA8L2xpbmVhckdyYWRpZW50PgogICAgICAgIDxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQyX2xpbmVhcl8zNzJfNDAyNTkiIHgxPSI0OS4zMDU3IiB5MT0iMi4wNzkiIHgyPSI4MC4zNjI3IiB5Mj0iOTMuNjU5NyIKICAgICAgICAgICAgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgogICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjRjVENDVFIiAvPgogICAgICAgICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiIC8+CiAgICAgICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDwvZGVmcz4KPC9zdmc+",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/braavos-wallet/jnlgamecbpmbajjfhmmmlhejkemejdma",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/braavos-wallet",
      edge: "https://microsoftedge.microsoft.com/addons/detail/braavos-wallet/hkkpjehhcnhgefhbdcgfkeegglpjchdc",
      ios: `https://link.braavos.app/dapp/${(V = ssrSafeWindow?.location) == null ? void 0 : V.host}`,
      android: `https://link.braavos.app/dapp/${($ = ssrSafeWindow?.location) == null ? void 0 : $.host}`
    }
  },
  {
    id: metaMaskVirtualWallet.id,
    name: metaMaskVirtualWallet.name,
    icon: metaMaskVirtualWallet.icon,
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/ether-metamask/",
      edge: "https://microsoftedge.microsoft.com/addons/detail/metamask/ejbalbakoplchlghecdalmeeeajnimhm?hl=en-US"
    }
  },
  {
    id: "okxwallet",
    name: "OKX Wallet",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJDSURBVHgB7Zq9jtpAEMfHlhEgQLiioXEkoAGECwoKxMcTRHmC5E3IoyRPkPAEkI7unJYmTgEFTYwA8a3NTKScLnCHN6c9r1e3P2llWQy7M/s1Gv1twCP0ej37dDq9x+Zut1t3t9vZjDEHIiSRSPg4ZpDL5fxkMvn1cDh8m0wmfugfO53OoFQq/crn8wxfY9EymQyrVCqMfHvScZx1p9ls3pFxXBy/bKlUipGPrVbLuQqAfsCliq3zl0H84zwtjQrOw4Mt1W63P5LvBm2d+Xz+YzqdgkqUy+WgWCy+Mc/nc282m4FqLBYL+3g8fjDxenq72WxANZbLJeA13zDX67UDioL5ybXwafMYu64Ltn3bdDweQ5R97fd7GyhBQMipx4POeEDHIu2LfDdBIGGz+hJ9CQ1ABjoA2egAZPM6AgiCAEQhsi/C4jHyPA/6/f5NG3Ks2+3CYDC4aTccDrn6ojG54MnEvG00GoVmWLIRNZ7wTCwDHYBsdACy0QHIhiuRETxlICWpMMhGZHmqS8qH6JLyGegAZKMDkI0uKf8X4SWlaZo+Pp1bRrwlJU8ZKLIvUjKh0WiQ3sRUbNVq9c5Ebew7KEo2m/1p4jJ4qAmDaqDQBzj5XyiAT4VCQezJigAU+IDU+z8vJFnGWeC+bKQV/5VZ71FV6L7PA3gg3tXrdQ+DgLhC+75Wq3no69P3MC0NFQpx2lL04Ql9gHK1bRDjsSBIvScBnDTk1WrlGIZBorIDEYJj+rhdgnQ67VmWRe0zlplXl81vcyEt0rSoYDUAAAAASUVORK5CYII=",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/mcohilncbfahbmgdjkbpemcciiolgcge",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/okexwallet",
      edge: "https://microsoftedge.microsoft.com/addons/detail/%E6%AC%A7%E6%98%93-web3-%E9%92%B1%E5%8C%85/pbpjkcldjiffchgbbndmhojiacbgflha",
      safari: "https://apps.apple.com/us/app/okx-wallet/id6463797825"
    }
  },
  {
    id: "keplr",
    name: "Keplr",
    icon: "data:image/png;base64,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",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/keplr/dmkamcknogkgcdfhhbddcghachkejeap",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/keplr",
      edge: "https://microsoftedge.microsoft.com/addons/detail/keplr/ocodgmmffbkkeecmadcijjhkmeohinei"
    }
  }
];
var T, _, R, F, X, P, W;
class LocalStorageWrapper {
  constructor(e) {
    x(this, F), x(this, P), x(this, T, !1), x(this, _, void 0), x(this, R, void 0), O(this, "value"), k(this, R, e), C(this, P, W).call(this);
  }
  set(e) {
    return !N(this, T) && !C(this, P, W).call(this) ? !1 : (this.delete(), this.value = e, e && (k(this, _, `${N(this, R)}-${generateUID()}`), localStorage.setItem(N(this, _), e)), !0);
  }
  get() {
    return C(this, F, X).call(this), this.value;
  }
  delete() {
    return !N(this, T) && !C(this, P, W).call(this) ? !1 : (this.value = null, N(this, _) && localStorage.removeItem(N(this, _)), !0);
  }
}
T = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakSet(), X = function() {
  this.value && this.set(this.value);
}, P = /* @__PURE__ */ new WeakSet(), W = function() {
  try {
    !N(this, T) && typeof window < "u" && (k(this, _, Object.keys(localStorage).find(
      (t) => t.startsWith(N(this, R))
    )), k(this, T, !0), N(this, _) && this.set(localStorage.getItem(N(this, _))));
  } catch (t) {
    console.warn(t);
  }
  return N(this, T);
};
const Permission = {
  ACCOUNTS: "accounts"
};
function filterBy(t, e) {
  var r, n;
  if ((r = e?.include) != null && r.length) {
    const o = new Set(e.include);
    return t.filter((i) => o.has(i.id));
  }
  if ((n = e?.exclude) != null && n.length) {
    const o = new Set(e.exclude);
    return t.filter((i) => !o.has(i.id));
  }
  return t;
}
const filterByAuthorized = async (t) => {
  const e = await Promise.all(
    t.map(async (r) => {
      try {
        return (await r.request({
          type: "wallet_getPermissions"
        })).includes(Permission.ACCOUNTS);
      } catch {
        return !1;
      }
    })
  );
  return t.filter((r, n) => e[n]);
}, virtualWalletKeys = ensureKeysArray({
  id: !0,
  name: !0,
  icon: !0,
  windowKey: !0,
  loadWallet: !0,
  hasSupport: !0
}), fullWalletKeys = ensureKeysArray({
  id: !0,
  name: !0,
  version: !0,
  icon: !0,
  request: !0,
  on: !0,
  off: !0
});
function createWalletGuard(t) {
  return function(e) {
    return e !== null && typeof e == "object" && t.every((r) => r in e);
  };
}
const isFullWallet = createWalletGuard(fullWalletKeys), isVirtualWallet = createWalletGuard(virtualWalletKeys);
function isWalletObject(t) {
  try {
    return isFullWallet(t) || isVirtualWallet(t);
  } catch {
  }
  return !1;
}
function scanObjectForWallets(t, e) {
  return Object.values(
    Object.getOwnPropertyNames(t).reduce((r, n) => {
      if (n.startsWith("starknet")) {
        const o = t[n];
        e(o) && !r[o.id] && (r[o.id] = o);
      }
      return r;
    }, {})
  );
}
const sortBy = (t, e) => {
  if (e && Array.isArray(e)) {
    t.sort((n, o) => e.indexOf(n.id) - e.indexOf(o.id));
    const r = t.length - e.length;
    return [
      ...t.slice(r),
      ...shuffle(t.slice(0, r))
    ];
  } else
    return shuffle(t);
}, virtualWallets = [metaMaskVirtualWallet];
function initiateVirtualWallets(t) {
  virtualWallets.forEach(async (e) => {
    await e.hasSupport(t) && (t[e.windowKey] = e);
  });
}
const virtualWalletsMap = {};
async function resolveVirtualWallet(t, e) {
  let r = virtualWalletsMap[e.id];
  return r || (r = await e.loadWallet(t), virtualWalletsMap[e.id] = r), r;
}
const defaultOptions = {
  windowObject: ssrSafeWindow ?? {},
  isWalletObject,
  storageFactoryImplementation: (t) => new LocalStorageWrapper(t)
};
function getStarknet(t = {}) {
  const { storageFactoryImplementation: e, windowObject: r, isWalletObject: n } = {
    ...defaultOptions,
    ...t
  }, o = e("gsw-last");
  return initiateVirtualWallets(r), {
    getAvailableWallets: async (i = {}) => {
      const s = scanObjectForWallets(
        r,
        n
      );
      return pipe$1(
        (a) => filterBy(a, i),
        (a) => sortBy(a, i.sort)
      )(s);
    },
    getAuthorizedWallets: async (i = {}) => {
      const s = scanObjectForWallets(
        r,
        n
      );
      return pipe$1(
        (a) => filterByAuthorized(a),
        (a) => filterBy(a, i),
        (a) => sortBy(a, i.sort)
      )(s);
    },
    getDiscoveryWallets: async (i = {}) => pipe$1(
      (s) => filterBy(s, i),
      (s) => sortBy(s, i.sort)
    )(wallets),
    getLastConnectedWallet: async () => {
      const i = o.get(), s = scanObjectForWallets(r, n).find(
        (u) => u.id === i
      ), [a] = await filterByAuthorized(
        s ? [s] : []
      );
      return a || (o.delete(), null);
    },
    enable: async (i, s) => {
      let a;
      if (isVirtualWallet(i))
        a = await resolveVirtualWallet(r, i);
      else if (isFullWallet(i))
        a = i;
      else
        throw new Error("Invalid wallet object");
      await a.request({
        type: "wallet_requestAccounts",
        params: {
          silent_mode: s?.silent_mode
        }
      });
      const u = await a.request({
        type: "wallet_getPermissions"
      });
      if (!(u != null && u.includes(Permission.ACCOUNTS)))
        throw new Error("Failed to connect to wallet");
      return o.set(a.id), a;
    },
    disconnect: async ({ clearLastWallet: i } = {}) => {
      i && o.delete();
    }
  };
}
const main = getStarknet(), isMobileDevice = () => {
  const t = navigator.userAgent.toLowerCase(), e = /android|webos|iphone|ipad|ipod|blackberry|windows phone/.test(t), r = "ontouchstart" in window || navigator.maxTouchPoints > 0, n = window.innerWidth <= 768;
  return e && (r || n);
}, defaultConnectors = ({
  argentMobileOptions: t,
  webWalletUrl: e
}) => {
  const r = typeof window < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1, n = [];
  return r || (n.push(
    new InjectedConnector({ options: { id: "argentX" } })
  ), n.push(
    new InjectedConnector({ options: { id: "braavos" } })
  )), n.push(new ArgentMobileBaseConnector(t)), isMobileDevice() && n.push(new BraavosMobileBaseConnector()), n.push(new WebWalletConnector({ url: e })), n;
}, BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
}, BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
}, PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
}, OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
}, ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class Utils {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(e, r) {
    const n = r.match(e);
    return n && n.length > 0 && n[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(e, r) {
    const n = r.match(e);
    return n && n.length > 1 && n[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(e, r, n) {
    if (e.test(r))
      return n;
  }
  static getWindowsVersionName(e) {
    switch (e) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(e) {
    const r = e.split(".").splice(0, 2).map((n) => parseInt(n, 10) || 0);
    if (r.push(0), r[0] === 10)
      switch (r[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(e) {
    const r = e.split(".").splice(0, 2).map((n) => parseInt(n, 10) || 0);
    if (r.push(0), !(r[0] === 1 && r[1] < 5)) {
      if (r[0] === 1 && r[1] < 6)
        return "Cupcake";
      if (r[0] === 1 && r[1] >= 6)
        return "Donut";
      if (r[0] === 2 && r[1] < 2)
        return "Eclair";
      if (r[0] === 2 && r[1] === 2)
        return "Froyo";
      if (r[0] === 2 && r[1] > 2)
        return "Gingerbread";
      if (r[0] === 3)
        return "Honeycomb";
      if (r[0] === 4 && r[1] < 1)
        return "Ice Cream Sandwich";
      if (r[0] === 4 && r[1] < 4)
        return "Jelly Bean";
      if (r[0] === 4 && r[1] >= 4)
        return "KitKat";
      if (r[0] === 5)
        return "Lollipop";
      if (r[0] === 6)
        return "Marshmallow";
      if (r[0] === 7)
        return "Nougat";
      if (r[0] === 8)
        return "Oreo";
      if (r[0] === 9)
        return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(e) {
    return e.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(e, r, n = !1) {
    const o = Utils.getVersionPrecision(e), i = Utils.getVersionPrecision(r);
    let s = Math.max(o, i), a = 0;
    const u = Utils.map([e, r], (l) => {
      const c = s - Utils.getVersionPrecision(l), d = l + new Array(c + 1).join(".0");
      return Utils.map(d.split("."), (m) => new Array(20 - m.length).join("0") + m).reverse();
    });
    for (n && (a = s - Math.min(o, i)), s -= 1; s >= a; ) {
      if (u[0][s] > u[1][s])
        return 1;
      if (u[0][s] === u[1][s]) {
        if (s === a)
          return 0;
        s -= 1;
      } else if (u[0][s] < u[1][s])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(e, r) {
    const n = [];
    let o;
    if (Array.prototype.map)
      return Array.prototype.map.call(e, r);
    for (o = 0; o < e.length; o += 1)
      n.push(r(e[o]));
    return n;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(e, r) {
    let n, o;
    if (Array.prototype.find)
      return Array.prototype.find.call(e, r);
    for (n = 0, o = e.length; n < o; n += 1) {
      const i = e[n];
      if (r(i, n))
        return i;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(e, ...r) {
    const n = e;
    let o, i;
    if (Object.assign)
      return Object.assign(e, ...r);
    for (o = 0, i = r.length; o < i; o += 1) {
      const s = r[o];
      typeof s == "object" && s !== null && Object.keys(s).forEach((u) => {
        n[u] = s[u];
      });
    }
    return e;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(e) {
    return BROWSER_ALIASES_MAP[e];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(e) {
    return BROWSER_MAP[e] || "";
  }
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i, browsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(t) {
      const e = {
        name: "Googlebot"
      }, r = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, t) || Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(t) {
      const e = {
        name: "Opera"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(t) {
      const e = {
        name: "Opera"
      }, r = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, t) || Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(t) {
      const e = {
        name: "Samsung Internet for Android"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/Whale/i],
    describe(t) {
      const e = {
        name: "NAVER Whale Browser"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(t) {
      const e = {
        name: "MZ Browser"
      }, r = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, t) || Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/focus/i],
    describe(t) {
      const e = {
        name: "Focus"
      }, r = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, t) || Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/swing/i],
    describe(t) {
      const e = {
        name: "Swing"
      }, r = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, t) || Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/coast/i],
    describe(t) {
      const e = {
        name: "Opera Coast"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(t) {
      const e = {
        name: "Opera Touch"
      }, r = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, t) || Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/yabrowser/i],
    describe(t) {
      const e = {
        name: "Yandex Browser"
      }, r = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, t) || Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(t) {
      const e = {
        name: "UC Browser"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(t) {
      const e = {
        name: "Maxthon"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/epiphany/i],
    describe(t) {
      const e = {
        name: "Epiphany"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/puffin/i],
    describe(t) {
      const e = {
        name: "Puffin"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/sleipnir/i],
    describe(t) {
      const e = {
        name: "Sleipnir"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/k-meleon/i],
    describe(t) {
      const e = {
        name: "K-Meleon"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/micromessenger/i],
    describe(t) {
      const e = {
        name: "WeChat"
      }, r = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, t) || Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(t) {
      const e = {
        name: /qqbrowserlite/i.test(t) ? "QQ Browser Lite" : "QQ Browser"
      }, r = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, t) || Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/msie|trident/i],
    describe(t) {
      const e = {
        name: "Internet Explorer"
      }, r = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/\sedg\//i],
    describe(t) {
      const e = {
        name: "Microsoft Edge"
      }, r = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(t) {
      const e = {
        name: "Microsoft Edge"
      }, r = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/vivaldi/i],
    describe(t) {
      const e = {
        name: "Vivaldi"
      }, r = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/seamonkey/i],
    describe(t) {
      const e = {
        name: "SeaMonkey"
      }, r = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/sailfish/i],
    describe(t) {
      const e = {
        name: "Sailfish"
      }, r = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/silk/i],
    describe(t) {
      const e = {
        name: "Amazon Silk"
      }, r = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/phantom/i],
    describe(t) {
      const e = {
        name: "PhantomJS"
      }, r = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/slimerjs/i],
    describe(t) {
      const e = {
        name: "SlimerJS"
      }, r = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(t) {
      const e = {
        name: "BlackBerry"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(t) {
      const e = {
        name: "WebOS Browser"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/bada/i],
    describe(t) {
      const e = {
        name: "Bada"
      }, r = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/tizen/i],
    describe(t) {
      const e = {
        name: "Tizen"
      }, r = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, t) || Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/qupzilla/i],
    describe(t) {
      const e = {
        name: "QupZilla"
      }, r = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, t) || Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(t) {
      const e = {
        name: "Firefox"
      }, r = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/electron/i],
    describe(t) {
      const e = {
        name: "Electron"
      }, r = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(t) {
      const e = {
        name: "Miui"
      }, r = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/chromium/i],
    describe(t) {
      const e = {
        name: "Chromium"
      }, r = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, t) || Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(t) {
      const e = {
        name: "Chrome"
      }, r = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/GSA/i],
    describe(t) {
      const e = {
        name: "Google Search"
      }, r = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Android Browser */
  {
    test(t) {
      const e = !t.test(/like android/i), r = t.test(/android/i);
      return e && r;
    },
    describe(t) {
      const e = {
        name: "Android Browser"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(t) {
      const e = {
        name: "PlayStation 4"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(t) {
      const e = {
        name: "Safari"
      }, r = Utils.getFirstMatch(commonVersionIdentifier, t);
      return r && (e.version = r), e;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(t) {
      const e = /^(.*)\/(.*) /, r = /^(.*)\/(.*)[ \t]\((.*)/, o = t.search("\\(") !== -1 ? r : e;
      return {
        name: Utils.getFirstMatch(o, t),
        version: Utils.getSecondMatch(o, t)
      };
    }
  }
], osParsersList = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(t) {
      const e = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, t);
      return {
        name: OS_MAP.Roku,
        version: e
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(t) {
      const e = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, t);
      return {
        name: OS_MAP.WindowsPhone,
        version: e
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(t) {
      const e = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, t), r = Utils.getWindowsVersionName(e);
      return {
        name: OS_MAP.Windows,
        version: e,
        versionName: r
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(t) {
      const e = {
        name: OS_MAP.iOS
      }, r = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, t);
      return r && (e.version = r), e;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(t) {
      const e = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, t).replace(/[_\s]/g, "."), r = Utils.getMacOSVersionName(e), n = {
        name: OS_MAP.MacOS,
        version: e
      };
      return r && (n.versionName = r), n;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(t) {
      const e = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, t).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version: e
      };
    }
  },
  /* Android */
  {
    test(t) {
      const e = !t.test(/like android/i), r = t.test(/android/i);
      return e && r;
    },
    describe(t) {
      const e = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, t), r = Utils.getAndroidVersionName(e), n = {
        name: OS_MAP.Android,
        version: e
      };
      return r && (n.versionName = r), n;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(t) {
      const e = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, t), r = {
        name: OS_MAP.WebOS
      };
      return e && e.length && (r.version = e), r;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(t) {
      const e = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, t) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, t) || Utils.getFirstMatch(/\bbb(\d+)/i, t);
      return {
        name: OS_MAP.BlackBerry,
        version: e
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(t) {
      const e = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, t);
      return {
        name: OS_MAP.Bada,
        version: e
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(t) {
      const e = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, t);
      return {
        name: OS_MAP.Tizen,
        version: e
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(t) {
      const e = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, t);
      return {
        name: OS_MAP.PlayStation4,
        version: e
      };
    }
  }
], platformParsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(t) {
      const e = Utils.getFirstMatch(/(can-l01)/i, t) && "Nova", r = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      return e && (r.model = e), r;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(t) {
      const e = t.test(/ipod|iphone/i), r = t.test(/like (ipod|iphone)/i);
      return e && !r;
    },
    describe(t) {
      const e = Utils.getFirstMatch(/(ipod|iphone)/i, t);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model: e
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(t) {
      return t.getBrowserName(!0) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(t) {
      return t.getBrowserName(!0) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(t) {
      return t.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(t) {
      const e = Number(String(t.getOSVersion()).split(".")[0]);
      return t.getOSName(!0) === "android" && e >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(t) {
      return t.getOSName(!0) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* desktop */
  {
    test(t) {
      return t.getOSName(!0) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(t) {
      return t.getOSName(!0) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* Linux */
  {
    test(t) {
      return t.getOSName(!0) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(t) {
      return t.getOSName(!0) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  /* Roku */
  {
    test(t) {
      return t.getOSName(!0) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
], enginesParsersList = [
  /* EdgeHTML */
  {
    test(t) {
      return t.getBrowserName(!0) === "microsoft edge";
    },
    describe(t) {
      if (/\sedg\//i.test(t))
        return {
          name: ENGINE_MAP.Blink
        };
      const r = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, t);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version: r
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(t) {
      const e = {
        name: ENGINE_MAP.Trident
      }, r = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Presto */
  {
    test(t) {
      return t.test(/presto/i);
    },
    describe(t) {
      const e = {
        name: ENGINE_MAP.Presto
      }, r = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Gecko */
  {
    test(t) {
      const e = t.test(/gecko/i), r = t.test(/like gecko/i);
      return e && !r;
    },
    describe(t) {
      const e = {
        name: ENGINE_MAP.Gecko
      }, r = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(t) {
      const e = {
        name: ENGINE_MAP.WebKit
      }, r = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  }
];
class Parser {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(e, r = !1) {
    if (e == null || e === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = e, this.parsedResult = {}, r !== !0 && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(e) {
    return e.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const e = Utils.find(browsersList, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.browser = e.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(e) {
    return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const e = Utils.find(osParsersList, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.os = e.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(e) {
    const { name: r } = this.getOS();
    return e ? String(r).toLowerCase() || "" : r || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(e = !1) {
    const { type: r } = this.getPlatform();
    return e ? String(r).toLowerCase() || "" : r || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const e = Utils.find(platformParsersList, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.platform = e.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(e) {
    return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const e = Utils.find(enginesParsersList, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.engine = e.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(e) {
    const r = {};
    let n = 0;
    const o = {};
    let i = 0;
    if (Object.keys(e).forEach((a) => {
      const u = e[a];
      typeof u == "string" ? (o[a] = u, i += 1) : typeof u == "object" && (r[a] = u, n += 1);
    }), n > 0) {
      const a = Object.keys(r), u = Utils.find(a, (c) => this.isOS(c));
      if (u) {
        const c = this.satisfies(r[u]);
        if (c !== void 0)
          return c;
      }
      const l = Utils.find(
        a,
        (c) => this.isPlatform(c)
      );
      if (l) {
        const c = this.satisfies(r[l]);
        if (c !== void 0)
          return c;
      }
    }
    if (i > 0) {
      const a = Object.keys(o), u = Utils.find(a, (l) => this.isBrowser(l, !0));
      if (u !== void 0)
        return this.compareVersion(o[u]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(e, r = !1) {
    const n = this.getBrowserName().toLowerCase();
    let o = e.toLowerCase();
    const i = Utils.getBrowserTypeByAlias(o);
    return r && i && (o = i.toLowerCase()), o === n;
  }
  compareVersion(e) {
    let r = [0], n = e, o = !1;
    const i = this.getBrowserVersion();
    if (typeof i == "string")
      return e[0] === ">" || e[0] === "<" ? (n = e.substr(1), e[1] === "=" ? (o = !0, n = e.substr(2)) : r = [], e[0] === ">" ? r.push(1) : r.push(-1)) : e[0] === "=" ? n = e.substr(1) : e[0] === "~" && (o = !0, n = e.substr(1)), r.indexOf(
        Utils.compareVersions(i, n, o)
      ) > -1;
  }
  isOS(e) {
    return this.getOSName(!0) === String(e).toLowerCase();
  }
  isPlatform(e) {
    return this.getPlatformType(!0) === String(e).toLowerCase();
  }
  isEngine(e) {
    return this.getEngineName(!0) === String(e).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(e, r = !1) {
    return this.isBrowser(e, r) || this.isOS(e) || this.isPlatform(e);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(e = []) {
    return e.some((r) => this.is(r));
  }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class Bowser {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(e, r = !1) {
    if (typeof e != "string")
      throw new Error("UserAgent should be a string");
    return new Parser(e, r);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(e) {
    return new Parser(e).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
}
const globalWindow = typeof window < "u" ? window : null;
function getStoreVersionFromBrowser() {
  if (!globalWindow)
    return null;
  switch (Bowser.getParser(globalWindow.navigator.userAgent).getBrowserName()?.toLowerCase()) {
    case "firefox":
      return "firefox";
    case "microsoft edge":
      return "edge";
    case "android browser":
    case "chrome":
    case "chromium":
    case "electron":
    case "opera":
    case "vivaldi":
      return "chrome";
    default:
      return null;
  }
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
const freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal$1 || freeSelf || Function("return this")();
const root$1 = root;
var Symbol$1 = root$1.Symbol;
const Symbol$2 = Symbol$1;
var objectProto$1 = Object.prototype, hasOwnProperty = objectProto$1.hasOwnProperty, nativeObjectToString$1 = objectProto$1.toString, symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(t) {
  var e = hasOwnProperty.call(t, symToStringTag$1), r = t[symToStringTag$1];
  try {
    t[symToStringTag$1] = void 0;
    var n = !0;
  } catch {
  }
  var o = nativeObjectToString$1.call(t);
  return n && (e ? t[symToStringTag$1] = r : delete t[symToStringTag$1]), o;
}
var objectProto = Object.prototype, nativeObjectToString = objectProto.toString;
function objectToString(t) {
  return nativeObjectToString.call(t);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(t) {
  return t == null ? t === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(t) ? getRawTag(t) : objectToString(t);
}
function isObjectLike(t) {
  return t != null && typeof t == "object";
}
var isArray = Array.isArray;
const isArray$1 = isArray;
var stringTag = "[object String]";
function isString(t) {
  return typeof t == "string" || !isArray$1(t) && isObjectLike(t) && baseGetTag(t) == stringTag;
}
const mapModalWallets = ({
  availableConnectors: t,
  installedWallets: e,
  discoveryWallets: r,
  storeVersion: n,
  customOrder: o
}) => {
  if (window?.starknet_argentX?.isInAppBrowser)
    return [];
  const a = e.map(
    (c) => t.find((d) => d.id === c.id)
  );
  return (o ? t : [
    ...t.filter((c) => a.includes(c)),
    ...t.filter((c) => !a.includes(c))
  ]).map((c) => {
    const d = e.find((g) => g.id === c.id);
    if (d) {
      const g = d.id === "argentX" ? { light: ARGENT_X_ICON, dark: ARGENT_X_ICON } : isString(d.icon) ? { light: d.icon, dark: d.icon } : d.icon;
      return {
        name: d.name,
        id: d.id,
        icon: g,
        connector: c
      };
    }
    const m = r.filter(
      (g) => !!g.downloads[n]
    ).find((g) => g.id === c.id);
    if (m) {
      const { downloads: g } = m, p = m.id === "argentX" ? ARGENT_X_ICON : m.icon;
      return {
        name: m.name,
        id: m.id,
        icon: { light: p, dark: p },
        connector: c,
        download: g[n]
      };
    }
    return !c || !c.id || !c.name ? null : {
      name: c.name,
      id: c.id,
      icon: c.icon,
      connector: c,
      title: "title" in c && isString(c.title) ? c.title : void 0,
      subtitle: "subtitle" in c && isString(c.subtitle) ? c.subtitle : void 0
    };
  }).filter((c) => c !== null);
};
function noop() {
}
function run(t) {
  return t();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(t) {
  t.forEach(run);
}
function is_function(t) {
  return typeof t == "function";
}
function safe_not_equal(t, e) {
  return t != t ? e == e : t !== e || t && typeof t == "object" || typeof t == "function";
}
let src_url_equal_anchor;
function src_url_equal(t, e) {
  return t === e ? !0 : (src_url_equal_anchor || (src_url_equal_anchor = document.createElement("a")), src_url_equal_anchor.href = e, t === src_url_equal_anchor.href);
}
function is_empty(t) {
  return Object.keys(t).length === 0;
}
function append(t, e) {
  t.appendChild(e);
}
function insert(t, e, r) {
  t.insertBefore(e, r || null);
}
function detach(t) {
  t.parentNode && t.parentNode.removeChild(t);
}
function destroy_each(t, e) {
  for (let r = 0; r < t.length; r += 1)
    t[r] && t[r].d(e);
}
function element(t) {
  return document.createElement(t);
}
function text(t) {
  return document.createTextNode(t);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(t, e, r, n) {
  return t.addEventListener(e, r, n), () => t.removeEventListener(e, r, n);
}
function attr(t, e, r) {
  r == null ? t.removeAttribute(e) : t.getAttribute(e) !== r && t.setAttribute(e, r);
}
function children(t) {
  return Array.from(t.childNodes);
}
function set_data(t, e) {
  e = "" + e, t.data !== e && (t.data = /** @type {string} */
  e);
}
function set_style(t, e, r, n) {
  r == null ? t.style.removeProperty(e) : t.style.setProperty(e, r, n ? "important" : "");
}
let current_component;
function set_current_component(t) {
  current_component = t;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(t) {
  get_current_component().$$.on_mount.push(t);
}
const dirty_components = [], binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [], resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = !1;
function schedule_update() {
  update_scheduled || (update_scheduled = !0, resolved_promise.then(flush));
}
function add_render_callback(t) {
  render_callbacks.push(t);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0)
    return;
  const t = current_component;
  do {
    try {
      for (; flushidx < dirty_components.length; ) {
        const e = dirty_components[flushidx];
        flushidx++, set_current_component(e), update(e.$$);
      }
    } catch (e) {
      throw dirty_components.length = 0, flushidx = 0, e;
    }
    for (set_current_component(null), dirty_components.length = 0, flushidx = 0; binding_callbacks.length; )
      binding_callbacks.pop()();
    for (let e = 0; e < render_callbacks.length; e += 1) {
      const r = render_callbacks[e];
      seen_callbacks.has(r) || (seen_callbacks.add(r), r());
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  for (; flush_callbacks.length; )
    flush_callbacks.pop()();
  update_scheduled = !1, seen_callbacks.clear(), set_current_component(t);
}
function update(t) {
  if (t.fragment !== null) {
    t.update(), run_all(t.before_update);
    const e = t.dirty;
    t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(t) {
  const e = [], r = [];
  render_callbacks.forEach((n) => t.indexOf(n) === -1 ? e.push(n) : r.push(n)), r.forEach((n) => n()), render_callbacks = e;
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  outros.r || run_all(outros.c), outros = outros.p;
}
function transition_in(t, e) {
  t && t.i && (outroing.delete(t), t.i(e));
}
function transition_out(t, e, r, n) {
  if (t && t.o) {
    if (outroing.has(t))
      return;
    outroing.add(t), outros.c.push(() => {
      outroing.delete(t), n && (r && t.d(1), n());
    }), t.o(e);
  } else
    n && n();
}
function ensure_array_like(t) {
  return t?.length !== void 0 ? t : Array.from(t);
}
function create_component(t) {
  t && t.c();
}
function mount_component(t, e, r) {
  const { fragment: n, after_update: o } = t.$$;
  n && n.m(e, r), add_render_callback(() => {
    const i = t.$$.on_mount.map(run).filter(is_function);
    t.$$.on_destroy ? t.$$.on_destroy.push(...i) : run_all(i), t.$$.on_mount = [];
  }), o.forEach(add_render_callback);
}
function destroy_component(t, e) {
  const r = t.$$;
  r.fragment !== null && (flush_render_callbacks(r.after_update), run_all(r.on_destroy), r.fragment && r.fragment.d(e), r.on_destroy = r.fragment = null, r.ctx = []);
}
function make_dirty(t, e) {
  t.$$.dirty[0] === -1 && (dirty_components.push(t), schedule_update(), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 | 0] |= 1 << e % 31;
}
function init(t, e, r, n, o, i, s = null, a = [-1]) {
  const u = current_component;
  set_current_component(t);
  const l = t.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: i,
    update: noop,
    not_equal: o,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(e.context || (u ? u.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty: a,
    skip_bound: !1,
    root: e.target || u.$$.root
  };
  s && s(l.root);
  let c = !1;
  if (l.ctx = r ? r(t, e.props || {}, (d, m, ...g) => {
    const p = g.length ? g[0] : m;
    return l.ctx && o(l.ctx[d], l.ctx[d] = p) && (!l.skip_bound && l.bound[d] && l.bound[d](p), c && make_dirty(t, d)), m;
  }) : [], l.update(), c = !0, run_all(l.before_update), l.fragment = n ? n(l.ctx) : !1, e.target) {
    if (e.hydrate) {
      const d = children(e.target);
      l.fragment && l.fragment.l(d), d.forEach(detach);
    } else
      l.fragment && l.fragment.c();
    e.intro && transition_in(t.$$.fragment), mount_component(t, e.target, e.anchor), flush();
  }
  set_current_component(u);
}
class SvelteComponent {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    G(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    G(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1), this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(e, r) {
    if (!is_function(r))
      return noop;
    const n = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
    return n.push(r), () => {
      const o = n.indexOf(r);
      o !== -1 && n.splice(o, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(e) {
    this.$$set && !is_empty(e) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1);
  }
}
const PUBLIC_VERSION = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
function create_else_block(t) {
  let e, r, n, o, i, s = (
    /*wallet*/
    (t[0].title ?? /*wallet*/
    t[0].name) + ""
  ), a, u, l, c = (
    /*wallet*/
    (t[0].subtitle ?? "") + ""
  ), d, m, g, p;
  function y(M, b) {
    return (
      /*loadingItem*/
      M[2] === /*wallet*/
      M[0]?.id ? create_if_block_1 : (
        /*isSvg*/
        M[4] ? create_if_block_2 : create_else_block_1
      )
    );
  }
  let w = y(t), h = w(t);
  return {
    c() {
      e = element("li"), r = element("span"), n = space(), o = element("div"), i = element("p"), a = text(s), u = space(), l = element("p"), d = text(c), m = space(), h.c(), attr(r, "class", "w-8 h-8"), attr(i, "class", "font-semibold text-base p"), attr(l, "class", "l2 p"), set_style(l, "text-align", "center"), attr(o, "class", "flex flex-col justify-center items-center"), attr(e, "class", `flex flex-row-reverse justify-between items-center 
            p-3 rounded-md cursor-pointer shadow-list-item 
            dark:shadow-none dark:bg-neutral-800 dark:text-white 
          hover:bg-neutral-100 dark:hover:bg-neutral-700 
          focus:outline-none focus:ring-2 
        focus:ring-neutral-200 dark:focus:ring-neutral-700 
          transition-colors`), attr(e, "role", "button"), attr(e, "tabindex", "0");
    },
    m(M, b) {
      insert(M, e, b), append(e, r), append(e, n), append(e, o), append(o, i), append(i, a), append(o, u), append(o, l), append(l, d), append(e, m), h.m(e, null), g || (p = [
        listen(
          e,
          "click",
          /*click_handler_1*/
          t[8]
        ),
        listen(
          e,
          "keyup",
          /*keyup_handler_1*/
          t[9]
        )
      ], g = !0);
    },
    p(M, b) {
      b & /*wallet*/
      1 && s !== (s = /*wallet*/
      (M[0].title ?? /*wallet*/
      M[0].name) + "") && set_data(a, s), b & /*wallet*/
      1 && c !== (c = /*wallet*/
      (M[0].subtitle ?? "") + "") && set_data(d, c), w === (w = y(M)) && h ? h.p(M, b) : (h.d(1), h = w(M), h && (h.c(), h.m(e, null)));
    },
    d(M) {
      M && detach(e), h.d(), g = !1, run_all(p);
    }
  };
}
function create_if_block$1(t) {
  let e, r, n, o, i, s, a = (
    /*wallet*/
    t[0].name + ""
  ), u, l, c, d, m, g, p, y, w;
  return {
    c() {
      e = element("a"), r = element("li"), n = element("span"), o = space(), i = element("p"), s = text("Install "), u = text(a), l = space(), c = element("img"), attr(n, "class", "w-8 h-8"), attr(i, "class", "font-semibold text-base p"), attr(c, "alt", d = /*wallet*/
      t[0].name), src_url_equal(c.src, m = /*icon*/
      t[3]) || attr(c, "src", m), attr(c, "class", "w-8 h-8 rounded-full"), attr(r, "class", `flex flex-row-reverse justify-between items-center 
              p-3 rounded-md cursor-pointer shadow-list-item 
              dark:shadow-none dark:bg-neutral-800 dark:text-white 
            hover:bg-neutral-100 dark:hover:bg-neutral-700`), attr(e, "aria-label", g = /*wallet*/
      t[0].name + " download link"), attr(e, "href", p = /*wallet*/
      t[0].download), attr(e, "target", "_blank"), attr(e, "rel", "noopener noreferrer"), attr(e, "class", `rounded-md focus:outline-none  focus:ring-2 
    focus:ring-neutral-200  dark:focus:ring-neutral-700 transition-colors`);
    },
    m(h, M) {
      insert(h, e, M), append(e, r), append(r, n), append(r, o), append(r, i), append(i, s), append(i, u), append(r, l), append(r, c), y || (w = [
        listen(
          r,
          "click",
          /*click_handler*/
          t[6]
        ),
        listen(
          r,
          "keyup",
          /*keyup_handler*/
          t[7]
        )
      ], y = !0);
    },
    p(h, M) {
      M & /*wallet*/
      1 && a !== (a = /*wallet*/
      h[0].name + "") && set_data(u, a), M & /*wallet*/
      1 && d !== (d = /*wallet*/
      h[0].name) && attr(c, "alt", d), M & /*wallet*/
      1 && g !== (g = /*wallet*/
      h[0].name + " download link") && attr(e, "aria-label", g), M & /*wallet*/
      1 && p !== (p = /*wallet*/
      h[0].download) && attr(e, "href", p);
    },
    d(h) {
      h && detach(e), y = !1, run_all(w);
    }
  };
}
function create_else_block_1(t) {
  let e, r, n;
  return {
    c() {
      e = element("img"), attr(e, "alt", r = /*wallet*/
      t[0]?.name), src_url_equal(e.src, n = /*icon*/
      t[3]) || attr(e, "src", n), attr(e, "class", "w-8 h-8 rounded");
    },
    m(o, i) {
      insert(o, e, i);
    },
    p(o, i) {
      i & /*wallet*/
      1 && r !== (r = /*wallet*/
      o[0]?.name) && attr(e, "alt", r);
    },
    d(o) {
      o && detach(e);
    }
  };
}
function create_if_block_2(t) {
  let e;
  return {
    c() {
      e = element("div"), set_style(e, "position", "relative");
    },
    m(r, n) {
      insert(r, e, n), e.innerHTML = /*icon*/
      t[3];
    },
    p: noop,
    d(r) {
      r && detach(e);
    }
  };
}
function create_if_block_1(t) {
  let e;
  return {
    c() {
      e = element("div"), e.innerHTML = '<svg aria-hidden="true" class="w-8 h-8 text-neutral-300 animate-spin dark:text-neutral-600 fill-neutral-600 dark:fill-neutral-300" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor"></path><path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill"></path></svg> <span class="sr-only">Loading...</span>', attr(e, "role", "status");
    },
    m(r, n) {
      insert(r, e, n);
    },
    p: noop,
    d(r) {
      r && detach(e);
    }
  };
}
function create_fragment$1(t) {
  let e;
  function r(i, s) {
    return (
      /*wallet*/
      i[0].download ? create_if_block$1 : create_else_block
    );
  }
  let n = r(t), o = n(t);
  return {
    c() {
      o.c(), e = empty();
    },
    m(i, s) {
      o.m(i, s), insert(i, e, s);
    },
    p(i, [s]) {
      n === (n = r(i)) && o ? o.p(i, s) : (o.d(1), o = n(i), o && (o.c(), o.m(e.parentNode, e)));
    },
    i: noop,
    o: noop,
    d(i) {
      i && detach(e), o.d(i);
    }
  };
}
function instance$1(t, e, r) {
  let { wallet: n } = e, { theme: o = null } = e, { cb: i = async () => {
  } } = e, { loadingItem: s = !1 } = e;
  const a = typeof n.icon == "string" ? n.icon : o === "dark" ? n.icon.dark : n.icon.light, u = a?.startsWith("<svg"), l = () => {
    i(null);
  }, c = (g) => {
    g.key === "Enter" && i(null);
  }, d = async () => {
    i(n.connector);
  }, m = async (g) => {
    g.key === "Enter" && i(n.connector);
  };
  return t.$$set = (g) => {
    "wallet" in g && r(0, n = g.wallet), "theme" in g && r(5, o = g.theme), "cb" in g && r(1, i = g.cb), "loadingItem" in g && r(2, s = g.loadingItem);
  }, [
    n,
    i,
    s,
    a,
    u,
    o,
    l,
    c,
    d,
    m
  ];
}
class ConnectorButton extends SvelteComponent {
  constructor(e) {
    super(), init(this, e, instance$1, create_fragment$1, safe_not_equal, {
      wallet: 0,
      theme: 5,
      cb: 1,
      loadingItem: 2
    });
  }
}
function get_each_context(t, e, r) {
  const n = t.slice();
  return n[16] = e[r], n;
}
function create_if_block(t) {
  let e, r, n, o, i, s, a, u, l, c, d, m, g, p, y, w = ensure_array_like(
    /*modalWallets*/
    t[1]
  ), h = [];
  for (let b = 0; b < w.length; b += 1)
    h[b] = create_each_block(get_each_context(t, w, b));
  const M = (b) => transition_out(h[b], 1, 1, () => {
    h[b] = null;
  });
  return {
    c() {
      e = element("div"), r = element("main"), n = element("header"), o = element("h2"), o.textContent = "Connect to", i = space(), s = element("h1"), a = text(
        /*dappName*/
        t[0]
      ), u = space(), l = element("span"), l.innerHTML = '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.77275 3.02275C9.99242 2.80308 9.99242 2.44692 9.77275 2.22725C9.55308 2.00758 9.19692 2.00758 8.97725 2.22725L6 5.20451L3.02275 2.22725C2.80308 2.00758 2.44692 2.00758 2.22725 2.22725C2.00758 2.44692 2.00758 2.80308 2.22725 3.02275L5.20451 6L2.22725 8.97725C2.00758 9.19692 2.00758 9.55308 2.22725 9.77275C2.44692 9.99242 2.80308 9.99242 3.02275 9.77275L6 6.79549L8.97725 9.77275C9.19692 9.99242 9.55308 9.99242 9.77275 9.77275C9.99242 9.55308 9.99242 9.19692 9.77275 8.97725L6.79549 6L9.77275 3.02275Z" fill="currentColor"></path></svg>', c = space(), d = element("ul");
      for (let b = 0; b < h.length; b += 1)
        h[b].c();
      attr(o, "class", "text-sm text-gray-400 font-semibold"), attr(s, "class", `text-xl font-semibold mb-6 
                  max-w-[240px] overflow-hidden 
                  whitespace-nowrap text-ellipsis`), attr(l, "class", `absolute top-0 right-0 p-2 cursor-pointer
                  rounded-full bg-neutral-100 dark:bg-neutral-800
                  text-neutral-400 dark:text-white
                  hover:bg-neutral-100 dark:hover:bg-neutral-700
                  focus:outline-none focus:ring-2
                focus:ring-neutral-200 dark:focus:ring-neutral-700
                  transition-colors`), attr(l, "role", "button"), attr(l, "tabindex", "0"), attr(l, "aria-label", "Close"), attr(n, "class", "flex items-center justify-center flex-col mb-2 relative"), attr(d, "class", "flex flex-col gap-3"), attr(r, "role", "dialog"), attr(r, "class", `rounded-3xl shadow-modal dark:shadow-none 
              w-full max-w-[380px] z-50 
              mx-6 p-6 pb-8 text-center 
              bg-slate-50 dark:bg-neutral-900 
            text-neutral-900 dark:text-white`), attr(e, "part", "starknetkit-modal"), attr(e, "class", m = `modal-font backdrop-blur-sm fixed inset-0 flex items-center 
            justify-center bg-black/25 z-[9999] ${/*darkModeControlClass*/
      t[4]}`);
    },
    m(b, A) {
      insert(b, e, A), append(e, r), append(r, n), append(n, o), append(n, i), append(n, s), append(s, a), append(n, u), append(n, l), append(r, c), append(r, d);
      for (let I = 0; I < h.length; I += 1)
        h[I] && h[I].m(d, null);
      g = !0, p || (y = [
        listen(
          l,
          "click",
          /*click_handler*/
          t[8]
        ),
        listen(
          l,
          "keyup",
          /*keyup_handler*/
          t[9]
        ),
        listen(r, "click", click_handler_1),
        listen(r, "keyup", keyup_handler_1),
        listen(
          e,
          "click",
          /*click_handler_2*/
          t[10]
        ),
        listen(
          e,
          "keyup",
          /*keyup_handler_2*/
          t[11]
        )
      ], p = !0);
    },
    p(b, A) {
      if ((!g || A & /*dappName*/
      1) && set_data(
        a,
        /*dappName*/
        b[0]
      ), A & /*modalWallets, loadingItem, cb, theme*/
      78) {
        w = ensure_array_like(
          /*modalWallets*/
          b[1]
        );
        let I;
        for (I = 0; I < w.length; I += 1) {
          const j = get_each_context(b, w, I);
          h[I] ? (h[I].p(j, A), transition_in(h[I], 1)) : (h[I] = create_each_block(j), h[I].c(), transition_in(h[I], 1), h[I].m(d, null));
        }
        for (group_outros(), I = w.length; I < h.length; I += 1)
          M(I);
        check_outros();
      }
      (!g || A & /*darkModeControlClass*/
      16 && m !== (m = `modal-font backdrop-blur-sm fixed inset-0 flex items-center 
            justify-center bg-black/25 z-[9999] ${/*darkModeControlClass*/
      b[4]}`)) && attr(e, "class", m);
    },
    i(b) {
      if (!g) {
        for (let A = 0; A < w.length; A += 1)
          transition_in(h[A]);
        g = !0;
      }
    },
    o(b) {
      h = h.filter(Boolean);
      for (let A = 0; A < h.length; A += 1)
        transition_out(h[A]);
      g = !1;
    },
    d(b) {
      b && detach(e), destroy_each(h, b), p = !1, run_all(y);
    }
  };
}
function create_each_block(t) {
  let e, r;
  return e = new ConnectorButton({
    props: {
      wallet: (
        /*wallet*/
        t[16]
      ),
      loadingItem: (
        /*loadingItem*/
        t[3]
      ),
      cb: (
        /*cb*/
        t[6]
      ),
      theme: (
        /*theme*/
        t[2]
      )
    }
  }), {
    c() {
      create_component(e.$$.fragment);
    },
    m(n, o) {
      mount_component(e, n, o), r = !0;
    },
    p(n, o) {
      const i = {};
      o & /*modalWallets*/
      2 && (i.wallet = /*wallet*/
      n[16]), o & /*loadingItem*/
      8 && (i.loadingItem = /*loadingItem*/
      n[3]), o & /*theme*/
      4 && (i.theme = /*theme*/
      n[2]), e.$set(i);
    },
    i(n) {
      r || (transition_in(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component(e, n);
    }
  };
}
function create_fragment(t) {
  let e, r, n = !/*isInAppBrowser*/
  t[5] && /*modalWallets*/
  t[1].length > 1 && create_if_block(t);
  return {
    c() {
      n && n.c(), e = empty();
    },
    m(o, i) {
      n && n.m(o, i), insert(o, e, i), r = !0;
    },
    p(o, [i]) {
      !/*isInAppBrowser*/
      o[5] && /*modalWallets*/
      o[1].length > 1 ? n ? (n.p(o, i), i & /*modalWallets*/
      2 && transition_in(n, 1)) : (n = create_if_block(o), n.c(), transition_in(n, 1), n.m(e.parentNode, e)) : n && (group_outros(), transition_out(n, 1, 1, () => {
        n = null;
      }), check_outros());
    },
    i(o) {
      r || (transition_in(n), r = !0);
    },
    o(o) {
      transition_out(n), r = !1;
    },
    d(o) {
      o && detach(e), n && n.d(o);
    }
  };
}
const click_handler_1 = (t) => t.stopPropagation(), keyup_handler_1 = (t) => {
  t.stopPropagation();
};
function instance(t, e, r) {
  let { dappName: n = window?.document.title ?? "" } = e, { modalWallets: o } = e, { callback: i = async () => {
  } } = e, { theme: s = null } = e, a = !1, l = window?.starknet_argentX?.isInAppBrowser;
  const d = navigator.userAgent.toLowerCase().includes("braavos"), m = (b) => {
    r(3, a = b);
  };
  let g = async (b) => {
    m(b?.id ?? !1);
    try {
      await i(b ?? null);
    } finally {
      m(!1);
    }
  }, p = s === "dark" ? "dark" : "";
  onMount(async () => {
    if (s === "dark" || s === null && window.matchMedia("(prefers-color-scheme: dark)").matches ? r(4, p = "dark") : r(4, p = ""), l && window?.starknet_argentX) {
      try {
        i(new InjectedConnector({ options: { id: "argentX" } }));
      } catch {
      }
      return;
    }
    if (d && window?.starknet_braavos) {
      try {
        i(new InjectedConnector({ options: { id: "braavos" } }));
      } catch {
      }
      return;
    }
    if (o.length === 1)
      try {
        const [b] = o;
        await i(b.connector);
      } catch (b) {
        console.error(b);
      }
  });
  const y = () => g(null), w = (b) => {
    b.key === "Enter" && g(null);
  }, h = () => g(null), M = (b) => {
    b.key === "Escape" && g(null);
  };
  return t.$$set = (b) => {
    "dappName" in b && r(0, n = b.dappName), "modalWallets" in b && r(1, o = b.modalWallets), "callback" in b && r(7, i = b.callback), "theme" in b && r(2, s = b.theme);
  }, [
    n,
    o,
    s,
    a,
    p,
    l,
    g,
    i,
    y,
    w,
    h,
    M
  ];
}
class Modal extends SvelteComponent {
  constructor(e) {
    super(), init(this, e, instance, create_fragment, safe_not_equal, {
      dappName: 0,
      modalWallets: 1,
      callback: 7,
      theme: 2
    });
  }
}
const css = `@import"https://fonts.googleapis.com/css2?family=Barlow:wght@500;600&display=swap";.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.visible{visibility:visible}.static{position:static}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.inset-0{inset:0}.right-0{right:0}.top-0{top:0}.z-50{z-index:50}.z-\\[9999\\]{z-index:9999}.mx-6{margin-left:1.5rem;margin-right:1.5rem}.mb-2{margin-bottom:.5rem}.mb-6{margin-bottom:1.5rem}.block{display:block}.inline{display:inline}.flex{display:flex}.h-8{height:2rem}.w-8{width:2rem}.w-full{width:100%}.max-w-\\[240px\\]{max-width:240px}.max-w-\\[380px\\]{max-width:380px}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes spin{to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite}.cursor-pointer{cursor:pointer}.flex-row-reverse{flex-direction:row-reverse}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-3{gap:.75rem}.overflow-hidden{overflow:hidden}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.rounded{border-radius:.25rem}.rounded-3xl{border-radius:1.5rem}.rounded-full{border-radius:9999px}.rounded-md{border-radius:.375rem}.border{border-width:1px}.bg-black\\/25{background-color:#00000040}.bg-neutral-100{--tw-bg-opacity: 1;background-color:rgb(245 245 245 / var(--tw-bg-opacity))}.bg-slate-50{--tw-bg-opacity: 1;background-color:rgb(248 250 252 / var(--tw-bg-opacity))}.fill-neutral-600{fill:#525252}.p-2{padding:.5rem}.p-3{padding:.75rem}.p-6{padding:1.5rem}.pb-8{padding-bottom:2rem}.text-center{text-align:center}.text-base{font-size:1rem;line-height:1.5rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.font-semibold{font-weight:600}.text-gray-400{--tw-text-opacity: 1;color:rgb(156 163 175 / var(--tw-text-opacity))}.text-neutral-300{--tw-text-opacity: 1;color:rgb(212 212 212 / var(--tw-text-opacity))}.text-neutral-400{--tw-text-opacity: 1;color:rgb(163 163 163 / var(--tw-text-opacity))}.text-neutral-900{--tw-text-opacity: 1;color:rgb(23 23 23 / var(--tw-text-opacity))}.shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-list-item{--tw-shadow: 0px 2px 12px rgba(0, 0, 0, .12);--tw-shadow-colored: 0px 2px 12px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-modal{--tw-shadow: 0px 4px 20px rgba(0, 0, 0, .5);--tw-shadow-colored: 0px 4px 20px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline{outline-style:solid}.blur{--tw-blur: blur(8px);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.backdrop-blur-sm{--tw-backdrop-blur: blur(4px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }.modal-font{font-family:Barlow,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-webkit-text-size-adjust:100%;-moz-text-size-adjust:100%;text-size-adjust:100%;font-feature-settings:"kern"}.l2{color:#8c8c8c;font-size:12px;font-weight:500;line-height:14px;letter-spacing:0em;text-align:left}.p{margin:0}.hover\\:bg-neutral-100:hover{--tw-bg-opacity: 1;background-color:rgb(245 245 245 / var(--tw-bg-opacity))}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\\:ring-2:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\:ring-neutral-200:focus{--tw-ring-opacity: 1;--tw-ring-color: rgb(229 229 229 / var(--tw-ring-opacity))}.dark\\:bg-neutral-800:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(38 38 38 / var(--tw-bg-opacity))}.dark\\:bg-neutral-900:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(23 23 23 / var(--tw-bg-opacity))}.dark\\:fill-neutral-300:is(.dark *){fill:#d4d4d4}.dark\\:text-neutral-600:is(.dark *){--tw-text-opacity: 1;color:rgb(82 82 82 / var(--tw-text-opacity))}.dark\\:text-white:is(.dark *){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.dark\\:shadow-none:is(.dark *){--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.dark\\:hover\\:bg-neutral-700:hover:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(64 64 64 / var(--tw-bg-opacity))}.dark\\:focus\\:ring-neutral-700:focus:is(.dark *){--tw-ring-opacity: 1;--tw-ring-color: rgb(64 64 64 / var(--tw-ring-opacity))}
`, useStarknetkitConnectModal = (t) => ({
  starknetkitConnectModal: async () => await connect({
    ...t,
    resultType: t?.resultType ?? "connector"
  })
});
let selectedConnector = null;
const connect = async ({
  modalMode: t = "canAsk",
  storeVersion: e = getStoreVersionFromBrowser(),
  modalTheme: r,
  dappName: n,
  resultType: o = "wallet",
  ...i
}) => {
  const { webWalletUrl: s = DEFAULT_WEBWALLET_URL, argentMobileOptions: a } = i, { connectors: u } = i;
  selectedConnector = null;
  const l = !u || u.length === 0 ? defaultConnectors({
    argentMobileOptions: a,
    webWalletUrl: s
  }) : u, c = localStorage.getItem("starknetLastConnectedWallet");
  if (t === "neverAsk")
    try {
      const p = l.find((w) => w.id === c) ?? null;
      let y = null;
      return p && o === "wallet" && (y = await p.connect()), {
        connector: p,
        wallet: p?.wallet ?? null,
        connectorData: y
      };
    } catch (p) {
      throw removeStarknetLastConnectedWallet(), new Error(p);
    }
  const d = await main.getAvailableWallets(i);
  if (t === "canAsk" && c && ((await main.getAuthorizedWallets(i)).find((w) => w.id === c) ?? d.length === 1 ? d[0] : void 0)) {
    const w = l.find((M) => M.id === c);
    let h = null;
    return o === "wallet" && (h = await w?.connect() ?? null), w && (selectedConnector = w), {
      connector: selectedConnector,
      connectorData: h,
      wallet: w?.wallet ?? null
    };
  }
  const m = mapModalWallets({
    availableConnectors: l,
    installedWallets: d,
    discoveryWallets: await main.getDiscoveryWallets(i),
    storeVersion: e,
    customOrder: u ? u?.length > 0 : !1
  }), g = () => {
    const p = "starknetkit-modal-container", y = document.getElementById(p);
    if (y) {
      if (y.shadowRoot)
        return y.shadowRoot;
      y.remove();
    }
    const w = document.createElement("div");
    w.id = p, document.body.appendChild(w);
    const h = w.attachShadow({ mode: "open" });
    return h.innerHTML = `<style>${css}</style>`, h;
  };
  return new Promise((p, y) => {
    const w = new Modal({
      target: g(),
      props: {
        dappName: n,
        callback: async (h) => {
          try {
            if (selectedConnector = h, o === "wallet") {
              const M = await h?.connect() ?? null;
              h !== null && setStarknetLastConnectedWallet(h.id), p({
                connector: h,
                connectorData: M,
                wallet: h?.wallet ?? null
              });
            } else
              p({
                connector: h,
                wallet: null,
                connectorData: null
              });
          } catch (M) {
            y(M);
          } finally {
            setTimeout(() => w.$destroy());
          }
        },
        theme: r === "system" ? null : r ?? null,
        modalWallets: m
      }
    });
  });
}, getSelectedConnectorWallet = () => selectedConnector ? selectedConnector.wallet : null, disconnect = async (t = {}) => (removeStarknetLastConnectedWallet(), selectedConnector && await selectedConnector.disconnect(), selectedConnector = null, main.disconnect(t));
export {
  connect,
  disconnect,
  getSelectedConnectorWallet,
  useStarknetkitConnectModal
};
